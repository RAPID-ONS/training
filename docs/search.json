{
  "articles": [
    {
      "path": "about.html",
      "title": "About this site",
      "author": [],
      "contents": "\r\nWho is RAPID and why we have created this page.\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-25T13:41:58+01:00"
    },
    {
      "path": "control_flow.html",
      "title": "Control Flow and Loops in R",
      "author": [],
      "contents": "\r\n\r\nContents\r\nWhat are loops?\r\nfor loops\r\nSyntax\r\nExample of the advantages of a for loop\r\nDo I have to use x?\r\nWill I actually use this much?\r\nMy loop is stuck!\r\n\r\nwhile loops\r\nSyntax\r\nExample of a while loop\r\nWill I actually use this much?\r\n\r\nif statements (control flow)\r\nSyntax\r\nRelational operators\r\nExample: traffic light\r\nelse\r\nelse if\r\nifelse\r\n\r\nCombining loops/conditional statements\r\nExample\r\nKeep track of your brackets\r\nAdvanced loop features:\r\n\r\nExercises\r\nSwitch\r\nFunctionals\r\napply()\r\nlapply()\r\nsapply()\r\nAdditional arguments\r\n\r\nVectorisation\r\nTiming\r\nThe tictoc package:\r\nComparison using tictoc\r\n\r\nPoll answers\r\n\r\nCourse details:\r\nPre-requisites:\r\nhave RStudio installed\r\npackages required: tidyverse and tictoc (advanced section)\r\nminimal basic R knowledge (e.g., variable assignment)\r\n\r\nUseful resources:\r\nThis is an introduction to control flow, but for more comprehensive overviews see:\r\nIntermediate R Course on DataCamp\r\nAdvanced R: Control flow\r\nGlossary\r\nHere is a glossary of some terms I may use in this presentation:\r\n\r\n\r\nJargon\r\n\r\n\r\nDefinition\r\n\r\n\r\nLinks to further info\r\n\r\n\r\nArgument\r\n\r\n\r\nThe input(s) to a function to make it do what you want.\r\n\r\n\r\nArgument\r\n\r\n\r\nConsole\r\n\r\n\r\nWhere the code runs. You can interact directly with the console (type in it). Or when you run code in the script, it prints/runs here. Printouts also are show here.\r\n\r\n\r\nConsole\r\n\r\n\r\nEnvironment\r\n\r\n\r\nGenerally talking about the global environment. Contains all the variables, data and functions that are accessible to the user.\r\n\r\n\r\nEnvironment\r\n\r\n\r\nFile path\r\n\r\n\r\nLocation/address of your folders, sub-folders and files inside your drives. Can be see in Window’s File Explorer address bar. Used to find and read in objects/data and save out objects/data.\r\n\r\n\r\nFile path\r\n\r\n\r\nIndent\r\n\r\n\r\nHow many tabs/spaces away from the right hand side of the script the code is written. R doesn’t generally mind about indents but there is best practice.\r\n\r\n\r\nIndent\r\n\r\n\r\nParentheses, Brackets, Bracers\r\n\r\n\r\nRound brackets (), Curly brackets {}, Square brackets []\r\n\r\n\r\nParentheses, Brackets, Bracers\r\n\r\n\r\nPipe\r\n\r\n\r\nThe operator %>% from magrittr which allows functions to be called on dataframes in a sequential order.\r\n\r\n\r\nPipe\r\n\r\n\r\nPrint/Printout\r\n\r\n\r\nOutputs text, data etc to the console.\r\n\r\n\r\nPrint/Printout\r\n\r\n\r\nReturn\r\n\r\n\r\nColloquially similar to printout but when regarding a function.\r\n\r\n\r\nReturn\r\n\r\n\r\nScript\r\n\r\n\r\nA text file containing code (a sequence of commands) that can be edited and saved. Code runs in the console.\r\n\r\n\r\nScript\r\n\r\n\r\nSyntax\r\n\r\n\r\nAkin to a languages grammar. A fancy way of saying how something in the code is written to get it to do what you want. The rules of writing code. Differs across different programming languages.\r\n\r\n\r\nSyntax\r\n\r\n\r\nTerminal\r\n\r\n\r\nProvides access to the system shell (command line interface with things like file explorer, Git).\r\n\r\n\r\nTerminal\r\n\r\n\r\nVariable assignment, Assign a variable\r\n\r\n\r\nSave something (data, value, function etc) to a variable, primarily using <- or =, so that it is availble in the environment to be used in the code.\r\n\r\n\r\nVariable assignment, Assign a variable\r\n\r\n\r\nWorking directory\r\n\r\n\r\nFolder where you are working. It’s the place (the environment) where you have to store your files of your project in order to load them or where your R objects will be saved.\r\n\r\n\r\nWorking directory\r\n\r\n\r\nWhat are loops?\r\nLoops are coding structures that help repeat highly similar or repetitive code effectively, without the need for copy-pasting. They increase code efficiency and readability.\r\nTypes of loops:\r\nfor loop (do something x times)\r\nwhile loop (do something until a certain event is reached)\r\nif statements (control flow, not actually a ‘proper’ loop)\r\nPoll 1: How confident are you with loops and control flow in R? (1 - not at all, 5 - very confident)\r\nfor loops\r\nWhat is a for loop? It does something repeatedly a certain amount of times.\r\nSyntax\r\nfor (values to loop over) {\r\n  do all of this stuff for the current value\r\n}\r\nThe for loop keeps repeating until the last value is reached.\r\nIn a bit more appropriate coding jargon:\r\nfor (var in seq) {\r\n  expr\r\n}\r\nWhere var = variable, seq = sequence, and expr = expression. You need to use these specific types of brackets in the correct place, otherwise the for loop won’t work.\r\nA really simple example is:\r\n\r\n\r\nfor (x in 1:10) {\r\n  print(x)\r\n}\r\n\r\n\r\nHere, x is defined as 1:10 (a sequence of 1 to 10 in steps of 1, i.e., 1, 2, 3, … 10). The first time the loop runs, x <- 1, so it prints 1. The second time, x <- 2, so it prints 2. Etc. Until x <- 10 has been printed, then it stops as x has no further values.\r\nPoll 2: What is the output of the following for loop: for (x in 1:2) { y <- x + 3, print(y) }\r\n1, 2\r\n3, 4\r\n4, 5\r\n5, 6\r\nAnswer\r\nExample of the advantages of a for loop\r\nConsider the following scenario. You want to create 3 variables, each is equal to the previous variable, plus 1.\r\n\r\n\r\na <- 1\r\nb <- a + 1\r\nc <- b + 1\r\nd <- c + 1\r\nprint(c(b, c, d))\r\n\r\n\r\nEasy enough to type out, right? If a is a different number, e.g., 3; b, c and d are still calculated correctly and you don’t need to change any lines other than the first where a value is assigned to a. Done!\r\nHowever, it turns out you now need to do the same thing, but rather than just 3 variables, you need to create 100! That’s a lot of copy-pasting to create e, f, g, …\r\nLet’s try to write a for loop to obtain the above 3 output variables:\r\n\r\n\r\ninput_variable <- 1\r\nnumber_of_outputs <- 3\r\noutput <- c() #empty vector to put outputs into\r\nfor (x in 1:number_of_outputs) {\r\n  output[x] <- x + 1\r\n}\r\nprint(output)\r\n\r\n\r\nNot only did you just do the same thing super fast, you also tidied the output into a single list, so you don’t clutter your workspace with lots of separate variables. If you needed the 3rd output, you can obtain it using:\r\n\r\n\r\noutput[3]\r\n\r\n\r\nHey, but that was more lines of code than the copy-pasting above! Yeah, well, now think about when you needed to do this 100 times, instead of 3. All you need to change is:\r\n\r\n\r\ninput_variable <- 1\r\nnumber_of_outputs <- 100\r\noutput <- c() #empty vector to put outputs into\r\nfor (x in 1:number_of_outputs) {\r\n  output[x] <- x + 1\r\n}\r\nprint(output)\r\n\r\n\r\nNo additional lines! And you can still easily change the input variable.\r\nDo I have to use x?\r\nNo! ‘x’ is just a placeholder variable (a bit of a habit in coding examples, you may also see ‘i’ used often), it can be anything you like. In fact, it is a better idea to give it a sensible name (ideally following coding style best practice!) so you and anybody else reading your code can remember/figure out what this loop is actually doing.\r\nLet’s try a more sensible example:\r\n\r\n\r\nbaby_names <- list(\"Oliver\", \"Leo\", \"Olivia\", \"Frank\")\r\n\r\nfor (baby_name in baby_names) {\r\n  print(baby_name)\r\n}\r\n\r\n\r\nWill I actually use this much?\r\nYes, a lot! It is a fundamental tool in coding. It takes some practice, but saves lots of time and effort in computing.\r\nMy loop is stuck!\r\nYour Console is hanging waiting for input, showing a ‘+’, and not a ‘>’. You have most likely forgotten a bracket somewhere. Press ESC and you can correct your loop and try again.\r\nwhile loops\r\nWhat is a while loop? It keeps on doing something continuously until a certain event is reached.\r\nSyntax\r\nwhile (condition) {\r\n  expr\r\n}\r\nWhere condition is a criterion that needs to be satisfied for the loop to keep on running, and expr = expression (some bit of code). The condition uses a Boolean statement, that is: TRUE of FALSE. As long as the condition equals TRUE, the while loop will keep on executing the expression. As soon as this condition equals FALSE, it stops.\r\nExample of a while loop\r\nYou have 20 apples. You are handing out 1 at a time to others. Once you only have 2 apples left, you want to stop handing them out, so that you have some for yourself.\r\n\r\n\r\nnum_apples <- 20\r\nwhile (num_apples > 2) {\r\n  print(\"Keep handing out apples\")\r\n  num_apples <- num_apples - 1\r\n}\r\nprint(paste0(\"Stop handing out apples, because you only have \", num_apples, \" left\"))\r\n\r\n\r\nWhat happened there? The loop ran initially with num_apples = 20. On the next iteration, num_apples <- 19, and 19 > 2 == TRUE, so it kept on running, then it was 18, 17, etc, until num_apples <- 2 and 2 > 2 == FALSE, so the loop stopped and the print line below the closing bracket of the loop was executed.\r\nFun anecdote - while (!!) I was writing this loop, I made a typo, which meant the loop kept going forever as the condition never changed to FALSE! (Try the following code, then Press ESC to exit the stuck loop):\r\nnum_apples <- 20\r\nwhile (num_apples > 2) {\r\n  print(\"Keep handing out apples\")\r\n  num_applies <- num_apples - 1\r\n}\r\nprint(num_apples)\r\nYou can see that num_apples never changed from 20, so the while condition remained TRUE at all times!\r\nWill I actually use this much?\r\nDepends. In analytical work, probably not as much as for loops. But it has its uses.\r\nExercises in breakout rooms: 15 min\r\nif statements (control flow)\r\nWhat is an if statement/control flow? It does what it suggests: conditional statements. If some criterion is TRUE, execute an expression. If it is FALSE, don’t execute the expression. This can be expanded with else if to include an additional alternative statement, and/or else to express what to do if none of the above criteria are satisfied (else always goes last).\r\nSyntax\r\nif (test_expression) {\r\n  statement\r\n}\r\nRelational operators\r\nYou need relational operators to run if statements. These simply compare a statement on the left with a statement on the right. Here is a list:\r\na == b “a is equal to b”\r\na > b “a is greater than b”\r\na >= b “a is greater than or equal to b”\r\na < b “a is smaller than b”\r\na <= b “a is smaller than or equal to b”\r\na != b “a is not equal to b”\r\nTry them out, for example:\r\n\r\n\r\na <- 1\r\nb <- 2\r\na == b\r\nb < a\r\na != b\r\n\r\n\r\nYou can see the output in the console is a boolean/logical value, either TRUE or FALSE.\r\nPoll 3: Given a <- 4 and b <- 6, what is the output to: a < b\r\n- 2\r\n- TRUE\r\n- YES\r\n- FALSE\r\nAnswer\r\nExample: traffic light\r\nLet’s try to code how a traffic light works. We’ll start with green:\r\n\r\n\r\nlight_status <- \"green\"\r\nif (light_status == \"green\") {\r\n  print(\"go\")\r\n}\r\n\r\n\r\nYou will get to “go” only if the light is green and for no other value. (Try some other values for light_status)\r\nelse\r\n\r\n\r\nlight_status <- \"green\"\r\nif (light_status == \"green\") {\r\n  print(\"go\")\r\n} else {\r\n  print(\"stop\")\r\n}\r\n\r\n\r\nSame as before, except anything other than green now gets a “stop” message. (Try some other values for light_status)\r\nelse if\r\n\r\n\r\nlight_status <- \"green\"\r\nif (light_status == \"green\") {\r\n  print(\"go\")\r\n} else if (light_status == \"orange\") {\r\n  print(\"stop if you are able to...\")\r\n} else {\r\n  print(\"stop\")\r\n}\r\n\r\n\r\nA green light still gets “go”, a red light still gets “stop”, but an orange light now gets a different message.\r\nThe traffic light works as it should! However… in coding you usually want to catch errors before they happen. Imagine the light cover is broken and the light is white. It might actually be a green, orange, or red. You will have to do a double take and determine which position the light is located and/or any further information available before deciding what to do. In the above example, anything other than green or orange would tell you to “stop”. We could expand this example by adding another else if statement:\r\n\r\n\r\nlight_status <- \"white\"\r\nif (light_status == \"green\") {\r\n  print(\"go\")\r\n} else if (light_status == \"orange\") {\r\n  print(\"stop if you are able to...\")\r\n} else if (light_status == \"red\") {\r\n  print(\"stop\")\r\n} else {\r\n  print(\"Warning: unexpected colour! Be careful and assess the situation...\")\r\n}\r\n\r\n\r\n(Try some other values for light_status)\r\nNow you have catered for all possible scenarios. You can add as many else if statements as you wish.\r\nifelse\r\nThere is a quicker way to code an if statement, whenever the situation is binary, i.e., there are only 2 options: if TRUE, do this, if FALSE, do that. There is a special built-in function in R to do this in one line:\r\nConsider the following 2-option if, else if statement, where there are no other scenarios possible:\r\n\r\n\r\nx <- 6\r\nif (x < 10) {\r\n  print(\"smaller than 10\")\r\n} else if (x >= 10) {\r\n  print(\"greater than 10\")\r\n}\r\n\r\n\r\nThis can be replaced with ifelse, syntax:\r\nifelse(test, yes, no)\r\nSo here, this would be:\r\n\r\n\r\nifelse(x < 10, print(\"smaller than 10\"), print(\"greater than 10\"))\r\n\r\n\r\n5 lines of code became 1. Please note to only use this function when you have a binary decision. If there are 3 or more options, you need the full-version if statement.\r\nA small note: note how R printed the output twice. Because ifelse is a function, it returns a value. So if you didn’t want R to print out the resulting value twice in the console, you would need to assign the output to a variable (using <- before ifelse).\r\nPoll 4: Given x <- 20, what is the output to: ifelse(x == 20, print(“FALSE”), print(“TRUE”))?\r\n- FALSE\r\n- TRUE\r\nAnswer\r\nCombining loops/conditional statements\r\nYou can combine any of the above loops/conditional statements by nesting them.\r\nExample\r\nLet’s combine an if statement and for loop. Let’s expand the baby names examples from earlier, and only print a name if the name was in the top 10 in 2021. We’ll need to draw from a database to do this.\r\n\r\n\r\nbaby_names <- list(\"Oliver\", \"Leo\", \"Olivia\", \"Frank\")\r\ntop_10_2021_boys <- c(\"Noah\", \"Oliver\", \"George\", \"Arthur\", \"Muhammad\", \"Leo\", \"Harry\", \"Oscar\", \"Archie\", \"Henry\")\r\n\r\nfor (baby_name in baby_names) {\r\n  if (baby_name %in% top_10_2021_boys) {\r\n    print(baby_name)\r\n  }\r\n}\r\n\r\n\r\nNote the use of %in% here for the if statement only. The for loop knows how to use a regular in, as it iterates over the contents of the sequence. However, the if statement requires a relational operator with result TRUE or FALSE. To check whether a variable is included within a list or vector, you can use %in% as you can see here.\r\nPoll 5. I want to print a baby name if it’s in the top 10, but only if there are more than 5 babies in my database. What type of control flow structure would I start with, i.e., my first/outer-most one?\r\n- a for loop\r\n- an if statement\r\n- a while loop\r\nAnswer\r\nKeep track of your brackets\r\nIn nested loops, it is easily done to forget a bracket or have an extra one. In your script, you can place your cursor directly after one of the brackets, and the corresponding bracket will be highlighted.\r\nTo keep track of your nested loops, and all the brackets required, it also helps a lot to use the correct indentation. You can re-indent lines automically by highlighting a section of code, then Code -> Reindent Lines, or use the shortcut ctrl-I.\r\nAdvanced loop features:\r\nBreak\r\nSometimes, you want the loop to run, but stop when a certain criterion is reached. In this scenario, you can use the break statement.\r\nAn example: you want to write out some data, but your system can’t handle more than 10 characters in the filename. Your for loop will print the output (in your real code, this would be a statement writing the data using the supplied filename), but it will first count the number of characters in your filename, and stop if the name is too long, so that your system doesn’t crash.\r\n\r\n\r\nfilenames <- c(\"filename1\", \"filename2\", \"fartoolongfilename3\", \"filename4\")\r\nfor (filename in filenames) {\r\n  if (nchar(filename) > 10) {\r\n    break\r\n  }\r\n  print(filename)\r\n}\r\n\r\n\r\nNext\r\nActually, we want the above loop to not just stop, but skip filenames that are too long and carry on with the next one! For this, you can use next.\r\n\r\n\r\nfilenames <- c(\"filename1\", \"filename2\", \"fartoolongfilename3\", \"filename4\")\r\nfor (filename in filenames) {\r\n  if (nchar(filename) > 10) {\r\n    next\r\n  }\r\n  print(filename)\r\n}\r\n\r\n\r\nLooping index\r\nAs you know, a for loop will run for all values within the sequence. It can be very useful to have access to the index that goes along with each value. For example, you can use this to store the output in a vector, or to use a counter. The index reflects the current iteration of the loop.\r\nThe following loop illustrates the difference between index and variable value:\r\n\r\n\r\nfilenames <- c(\"filename1\", \"filename2\", \"fartoolongfilename3\", \"filename4\")\r\nfor (index in 1:length(filenames)) {\r\n  print(paste0(\"index: \", index))\r\n  print(paste0(\"current element: \", filenames[index]))\r\n}\r\n\r\n\r\nAnd a numerical example, to show how you can use this to store results in a new vector:\r\n\r\n\r\ninput <- c(6, 3, 10, 2)\r\nresult <- c()\r\nfor (i in 1:length(input)) {\r\n  print(paste0(\"index: \", i))\r\n  print(paste0(\"current value: \", input[i]))\r\n  result[i] <- input[i] * 2\r\n}\r\n\r\n\r\nNote: seq_along() can be used in place of 1:length(input). This is a built-in method that, by default, creates a sequence of consecutive integers from 1 to the length of the object (vector, list, data frame).\r\n\r\n\r\ninput <- c(6, 3, 10, 2)\r\nseq_along(input)\r\n\r\n[1] 1 2 3 4\r\n\r\ni.e., the previous for loop can be written as:\r\n\r\n\r\ninput <- c(6, 3, 10, 2)\r\nresult <- c()\r\nfor (i in seq_along(input)) {\r\n  print(paste0(\"index: \", i))\r\n  print(paste0(\"current value: \", input[i]))\r\n  result[i] <- input[i] * 2\r\n}\r\n\r\n\r\nExercises\r\nPlease see Controlflow_Exercises.R\r\n(and afterwards Controlflow_Exercise_Solutions.R)\r\nHere are some additional beginner’s exercises you can try, with hints and solutions if you get stuck.\r\nAnd some additional advanced material including exercises: Advanced R: Control flow\r\nSwitch\r\nswitch() is a function included in base R. It evaluates the first argument, EXPR, and then selects the output from one of the further arguments. It is most applicable for cases when EXPR has a character-string value.\r\nSyntax:\r\n\r\n\r\nswitch(EXPR, ...)\r\n\r\n\r\nThe last argument in the function determines the output if none of the previous conditions are matched. If this is left blank and the input is unmatched, it will return NULL.\r\nRedoing the traffic light example with switch:\r\n\r\n\r\ncolour <- \"green\"\r\nswitch(colour,\r\n       red = \"stop\",\r\n       orange = \"stop if you are able to...\",\r\n       green = \"go\",\r\n       \"Warning: unexpected colour! Be careful and assess the situation...\")\r\n\r\n[1] \"go\"\r\n\r\n\r\n\r\ncolour <- \"white\"\r\nswitch(colour,\r\n       red = \"stop\",\r\n       orange = \"stop if you are able to...\",\r\n       green = \"go\",\r\n       \"Warning: unexpected colour! Be careful and assess the situation...\")\r\n\r\n[1] \"Warning: unexpected colour! Be careful and assess the situation...\"\r\n\r\nYou can find further information/examples here and here.\r\nFunctionals\r\nFunctionals are functions which take another function as an argument, and return an object. The aim is to turn looped code into a function, which is then called on every element in the object (list, vector, matrix, etc.). The functions used within functionals can be base R, imported from a package, or custom made.\r\n\r\nThe apply family of functions are a group of functionals included in base R. Using these will avoid having to explicitly write a loop, and can make code cleaner and more efficient.\r\n\r\napply()\r\napply() allows you to apply a function (FUN) over the margin of an array (X), and requires a dimension argument (MARGIN). The MARGIN argument determines which values are passed through the function. For 2-D arrays (matrices), MARGIN = 1 indicates rows, and MARGIN = 2 indicates columns.\r\nSyntax:\r\n\r\n\r\napply(X, MARGIN, FUN, ...)\r\n\r\n\r\nFor example, the code below uses apply() and the max() function to find the maximum value of each column of a matrix (MARGIN = 2) and then the maximum value of each row (MARGIN = 1).\r\n\r\n\r\nmy_matrix <- matrix(c(1, 5, 6, 7, 3, 1, 9, 5, 2, 4, 6, 4), nrow = 4)\r\nmy_matrix\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    3    2\r\n[2,]    5    1    4\r\n[3,]    6    9    6\r\n[4,]    7    5    4\r\n\r\napply(my_matrix, 2, max)\r\n\r\n[1] 7 9 6\r\n\r\napply(my_matrix, 1, max)\r\n\r\n[1] 3 5 9 7\r\n\r\n\r\n\r\nlapply()\r\nlapply() takes an object (X), and applies a function (FUN) to each element of the object (list, vector, matrix, etc), returning a list of the same length.\r\nSyntax:\r\n\r\n\r\nlapply(X, FUN, ...)\r\n\r\n\r\nFor example, the code below uses lapply() to round each element of my_list using the round() function.\r\n\r\n\r\nmy_list <- list(A = c(1.36, 2.51, 7.70),\r\n                B = c(9.50, 5.66, 2.55),\r\n                C = c(4.02, 1.65, 3.11))\r\n\r\nrounded_list <- lapply(my_list, round)\r\nrounded_list\r\n\r\n$A\r\n[1] 1 3 8\r\n\r\n$B\r\n[1] 10  6  3\r\n\r\n$C\r\n[1] 4 2 3\r\n\r\nIf we try to do this without using a functional, an error will be returned:\r\n\r\n\r\nround(my_list)\r\n\r\nError in round(my_list): non-numeric argument to mathematical function\r\n\r\n\r\nsapply()\r\nsapply() is very similar to lapply(). The input is the same, however it tries to simplify the output. It will try to return a vector or matrix where possible, e.g.:\r\n\r\n\r\nrounded_list_simplified <- sapply(my_list, round)\r\nrounded_list_simplified\r\n\r\n     A  B C\r\n[1,] 1 10 4\r\n[2,] 3  6 2\r\n[3,] 8  3 3\r\n\r\n\r\nAdditional arguments\r\nAny additional arguments to the function used in the functional can also be added.\r\nThe round() function defaults to rounding to an integer, however we can change this to 1 decimal place by adding digits = 1:\r\n\r\n\r\nrounded_list_simplified <- sapply(my_list, round, digits = 1)\r\nrounded_list_simplified\r\n\r\n       A   B   C\r\n[1,] 1.4 9.5 4.0\r\n[2,] 2.5 5.7 1.6\r\n[3,] 7.7 2.5 3.1\r\n\r\nThe family also includes other variations such as mapply(), and tapply() that we will not cover.\r\nAdapted from dataquest\r\n\r\nTidyverse equivalent\r\nThe tidyverse has a package called purrr which contains useful functional programming tools. You can find out more here.\r\n\r\nVectorisation\r\nAlthough functionals avoid explicitly writing loops, they still iterate over each element in the object. Vectorising code refers to using objects as a whole, i.e., operating on all elements at once, and is therefore much faster. Most of the functions in base R and other packages are already vectorised, such as dplyr.\r\nFor example, when adding two vectors (x and y), we could add each element together in a loop:\r\n\r\n\r\nx <- c(2:5)\r\ny <- c(6:9)\r\n\r\noutput <- c()\r\nfor (i in 1:4){\r\n  output[i] <- x[i] + y[i]\r\n}\r\noutput\r\n\r\n[1]  8 10 12 14\r\n\r\nOr we could add the two objects together:\r\n\r\n\r\noutput <- x + y\r\noutput\r\n\r\n[1]  8 10 12 14\r\n\r\nAdapted from swcarpentry\r\n\r\nTiming\r\nThe tictoc package:\r\nIn addition to writing more concise code, functionals and vectorisation can improve efficiency. We can test this using the tictoc package, which times how long a task takes to run.\r\ntic() starts the timer, toc() ends it, and a title can be added within tic(), e.g.:\r\n\r\n\r\nx <- runif(2e4)\r\n\r\ntic(\"Rounding 20,000 random values in x to 2 d.p. using for loop\")\r\n\r\nfor (i in 1:length(x)){\r\n  round(x, digits = 2)\r\n}\r\n\r\ntoc()\r\n\r\nRounding 20,000 random values in x to 2 d.p. using for loop: 17.9 sec elapsed\r\n\r\nTiming the same code may vary on each run (due other computer processes), so repeating this will ensure accurate results.\r\nThis is the simplest way to time tasks, however there are better packages for measuring performance and profiling such as profvis and bench.\r\n\r\nComparison using tictoc\r\nState if a value is even or odd\r\ndf is a data frame with 2 columns: x and even_odd.\r\nx is the integers from 2 to 200,000, and even_odd is currently full of NAs.\r\n\r\n\r\nx <- c(2:2e5)\r\n\r\ndf <- data.frame(x, even_odd = c(NA))\r\n\r\nhead(df)\r\n\r\n  x even_odd\r\n1 2       NA\r\n2 3       NA\r\n3 4       NA\r\n4 5       NA\r\n5 6       NA\r\n6 7       NA\r\n\r\n\r\nThe task is to fill the even_odd column based on value of x (either “even” or “odd”).\r\nUsing the tictoc package, we will compare the speeds of a variety of methods to do this:\r\nfor loop\r\nifelse\r\nfunctional (sapply)\r\nvectorisation\r\ndplyr\r\nThe modulo operator, %%, will be used. %% returns the remainder of the division of 2 numbers, e.g.,:\r\n5 %% 2 = 1 and 6 %% 3 = 0.\r\n\r\nfor loop\r\nFirstly, we will use a for loop:\r\n\r\n\r\ntic(\"for loop- even/odd\")\r\nfor (i in 1:length(df$x)) {\r\n  if (df$x[i] %% 2 == 0) {\r\n    df$even_odd[i] <- \"even\"\r\n  } else {\r\n    df$even_odd[i] <- \"odd\"\r\n  }\r\n}\r\ntoc()\r\n\r\nfor loop- even/odd: 76.58 sec elapsed\r\n\r\n\r\nWe will reset the data frame every time, to ensure that the timing is fair for each method.\r\n\r\n\r\ndf$even_odd <- c(NA)\r\n\r\n\r\n\r\nifelse\r\nNext, we will use the ifelse function:\r\n\r\n\r\ntic(\"ifelse - even/odd\")\r\ndf$even_odd <- ifelse(x %% 2 == 0, \"even\", \"odd\")\r\ntoc()\r\n\r\nifelse - even/odd: 0.07 sec elapsed\r\n\r\n\r\nResetting the even_odd column of the data frame:\r\n\r\n\r\ndf$even_odd <- c(NA)\r\n\r\n\r\n\r\nsapply\r\nNow we will use a functional: sapply.\r\nThe sapply function needs a function to be applied. The function func_even_odd() has been created for this:\r\n\r\n\r\nfunc_even_odd <- function(x) {\r\n  if (x %% 2 == 0) {\r\n    \"even\"\r\n  } else {\r\n    \"odd\"\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\ntic(\"sapply - even/odd\")\r\ndf$even_odd <- sapply(df$x, func_even_odd)\r\ntoc()\r\n\r\nsapply - even/odd: 0.17 sec elapsed\r\n\r\n\r\nVectorisation\r\nNext we will use vectorised code:\r\n\r\n\r\ndf$even_odd <- c(NA)\r\n\r\ntic(\"vectorised - even/odd\")\r\ndf$even_odd[df$x %% 2 == 0] <- \"even\"\r\ndf$even_odd[df$x %% 2 != 0] <- \"odd\"\r\ntoc()\r\n\r\nvectorised - even/odd: 0.02 sec elapsed\r\n\r\n\r\ndplyr\r\nFinally, we will use the dplyr package, using mutate() and case_when():\r\n\r\n\r\ndf$even_odd <- c(NA)\r\n\r\ntic(\"dplyr - even/odd\")\r\ndf <- dplyr::mutate(df, even_odd = dplyr::case_when(x %% 2 == 0 ~ \"even\",\r\n                                                    x %% 2 != 0 ~ \"odd\"))\r\ntoc()\r\n\r\ndplyr - even/odd: 0.08 sec elapsed\r\n\r\n\r\nWe can see that using an explicit for loop takes the longest by far, and that using sapply improves the speed.\r\nThe vectorised code is the quickest of all methods, however, readability and interpretability are important, which can sometimes be an issue.\r\ncase_when allows the vectorisation of ifelse statements. We can see that for this task, where there is only two options, the speed and readability are similar. However, if there are more than two options, case_when is preferable, to avoid nested ifelse statements.\r\nPoll answers\r\n2: What is the output of the following for loop: for (x in 1:2) { y <- x + 3, print(y) }4, 5\r\n3: Given a <- 4 and b <- 6, what is the output to: a < bTRUE\r\n4: Given x <- 20, what is the output to: ifelse(x == 20, print(“FALSE”), print(“TRUE”))?FALSE\r\nPoll 5. I want to print a baby name if it’s in the top 10, but only if there are more than 5 babies in my database. What type of control flow structure would I start with, i.e., my first/outer-most one?\r\nan if statement\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-25T13:43:48+01:00"
    },
    {
      "path": "functions.html",
      "title": "Functions in R",
      "author": [],
      "contents": "\r\n\r\nContents\r\nWhat are Functions?\r\nBenefit of Functions\r\nThree Elements of a Function\r\nAnalogy: Baking a Cake\r\nTwo main types of function:\r\n\r\nHow to write and call a function\r\nSimple/Sub-Functions\r\nWrapper Functions\r\n\r\nArguments\r\nRequired arguments\r\nDefault arguments\r\nAssignment\r\nOrder of arguments for existing and own functions\r\n\r\nINTRO BREAKOUT ROOMS\r\nBest Practice Style of Function\r\nFunction name\r\nLines\r\nSpacing\r\nIndentation\r\nReturns\r\nAssignment\r\nArguments\r\nComments\r\nPiping %>% style/dplyr (Advanced)\r\n\r\nDocumentation (docstrings)\r\nFunction documentation: roxygen2\r\n\r\nPiping %>%\r\nWarnings and Errors\r\nWarnings\r\nErrors\r\n\r\nINTRO BREAKOUT ROOMS\r\nADVANCED BREAKOUT ROOMS\r\nIntermediate/Advanced Functions\r\nLists of functions\r\nFunctionals\r\nAnonymous functions\r\nFunctions with Dynamic Arguments\r\nData Masking\r\nTidy Selection\r\n\r\nADVANCED BREAKOUT ROOMS\r\nPoll Answers\r\n\r\nPrerequisites:\r\nRStudio and R installed on laptop\r\nPackages required: tidyverse\r\n\r\nBasic R coding\r\nRequired for Advanced section: Coding in dplyr\r\nClick here to skip to the Advanced Section.\r\nGlossary\r\nHere is a glossary of some terms I may use in this presentation and some links to learn more:\r\n\r\n\r\nJargon\r\n\r\n\r\nDefinition\r\n\r\n\r\nLinks to further info\r\n\r\n\r\nArgument\r\n\r\n\r\nThe input(s) to a function to make it do what you want.\r\n\r\n\r\nArgument\r\n\r\n\r\nConsole\r\n\r\n\r\nWhere the code runs. You can interact directly with the console (type in it). Or when you run code in the script, it prints/runs here. Printouts also are show here.\r\n\r\n\r\nConsole\r\n\r\n\r\nEnvironment\r\n\r\n\r\nGenerally talking about the global environment. Contains all the variables, data and functions that are accessible to the user.\r\n\r\n\r\nEnvironment\r\n\r\n\r\nFile path\r\n\r\n\r\nLocation/address of your folders, sub-folders and files inside your drives. Can be see in Window’s File Explorer address bar. Used to find and read in objects/data and save out objects/data.\r\n\r\n\r\nFile path\r\n\r\n\r\nIndent\r\n\r\n\r\nHow many tabs/spaces away from the right hand side of the script the code is written. R doesn’t generally mind about indents but there is best practice.\r\n\r\n\r\nIndent\r\n\r\n\r\nParentheses, Brackets, Bracers\r\n\r\n\r\nRound brackets (), Curly brackets {}, Square brackets []\r\n\r\n\r\nParentheses, Brackets, Bracers\r\n\r\n\r\nPipe\r\n\r\n\r\nThe operator %>% from magrittr which allows functions to be called on dataframes in a sequential order.\r\n\r\n\r\nPipe\r\n\r\n\r\nPrint/Printout\r\n\r\n\r\nOutputs text, data etc to the console.\r\n\r\n\r\nPrint/Printout\r\n\r\n\r\nReturn\r\n\r\n\r\nColloquially similar to printout but when regarding a function.\r\n\r\n\r\nReturn\r\n\r\n\r\nScript\r\n\r\n\r\nA text file containing code (a sequence of commands) that can be edited and saved. Code runs in the console.\r\n\r\n\r\nScript\r\n\r\n\r\nSyntax\r\n\r\n\r\nAkin to a languages grammar. A fancy way of saying how something in the code is written to get it to do what you want. The rules of writing code. Differs across different programming languages.\r\n\r\n\r\nSyntax\r\n\r\n\r\nTerminal\r\n\r\n\r\nProvides access to the system shell (command line interface with things like file explorer, Git).\r\n\r\n\r\nTerminal\r\n\r\n\r\nVariable assignment, Assign a variable\r\n\r\n\r\nSave something (data, value, function etc) to a variable, primarily using <- or =, so that it is availble in the environment to be used in the code.\r\n\r\n\r\nVariable assignment, Assign a variable\r\n\r\n\r\nWorking directory\r\n\r\n\r\nFolder where you are working. It’s the place (the environment) where you have to store your files of your project in order to load them or where your R objects will be saved.\r\n\r\n\r\nWorking directory\r\n\r\n\r\nPoll: What words come to mind when I say “Functions”?\r\nWhat are Functions?\r\nCollection of statements orchestrated together to perform a specific operation.\r\nA function takes input (arguments), applies a method (code) to those arguments and returns the output.\r\nHopefully everyone in this session has experience of using functions when they code in R.\r\nE.g. sum() or mean().Note: Functions are objects, just as vectors are objects.\r\nBenefit of Functions\r\nReduce repetition\r\nReproducibility\r\nShorten code\r\nEditability\r\nTime-saving\r\nQuality\r\n\r\n\r\n##### We want the average Petal Length/Petal Width ratio for the Sepal Lengths\r\n  # of less than 5\r\n  ##### For each species separately (setosa, versicolor, virginica)\r\n\r\n### Example of repetitive code\r\n\r\nsetosa <- iris[iris$Species == \"setosa\", ]\r\nsetosa <- setosa[setosa$Sepal.Length < 7, ]\r\nsetosa$petal_length_width_ratio <- setosa$Petal.Length / setosa$Petal.Width\r\nmean(setosa$petal_length_width_ratio)\r\n\r\n[1] 6.908\r\n\r\nversicolor <- iris[iris$Species == \"versicolor\", ]\r\nversicolor <- versicolor[versicolor$Sepal.Length < 7, ]\r\nversicolor$petal_length_width_ratio <-\r\n  versicolor$Petal.Length / versicolor$Petal.Width\r\nmean(versicolor$petal_length_width_ratio)\r\n\r\n[1] 3.240504\r\n\r\nvirginica <- iris[iris$Species == \"virginica\", ]\r\nvirginica <- virginica[virginica$Sepal.Length < 7, ]\r\nvirginica$petal_length_width_ratio <-\r\n  virginica$Petal.Length / virginica$Petal.Width\r\nmean(virginica$petal_length_width_ratio)\r\n\r\n[1] 2.676954\r\n\r\n### Example of functionalised code\r\n\r\niris_function <- function(data, species) {\r\n  data <- data[(data$Species == species) & (data$Sepal.Length < 7), ]\r\n  data$petal_length_width_ratio <- data$Petal.Length / data$Petal.Width\r\n  mean(data$petal_length_width_ratio)\r\n}\r\n\r\niris_function(iris, \"setosa\")\r\n\r\n[1] 6.908\r\n\r\niris_function(iris, \"versicolor\")\r\n\r\n[1] 3.240504\r\n\r\niris_function(iris, \"virginica\")\r\n\r\n[1] 2.676954\r\n\r\nThree Elements of a Function\r\nArguments\r\nControls how you call the function.\r\nCan check it with: formals(function_name)\r\nBody\r\nThe code inside a function.\r\nCan check it with: body(function_name)\r\nEnvironment (Advanced)\r\nThe data structure that determines how the function finds the values associated with the names.\r\nCan check it with: environment(function_name)\r\nAnalogy: Baking a Cake\r\nA pipeline consists of multiple steps (involving functions) to achieve a desired output, just like how a cake recipe has steps/instructions to make a cake.\r\nLet’s simplify that and say that each step of a pipeline can a function a.k.a. a step of the recipe.\r\nFor Example - Cream together the butter and sugar in a mixing bowl with a wooden spoon until light and fluffy :\r\nThe ingredients (butter and sugar) are the arguments.\r\nThe bowl and spoon are your cooking tools, similar to existing functions that you want to use in your custom function. These may not be needed for all functions but can make what you are doing much easier!\r\nThe method of creaming the ingredients using the tools you need is the code body.\r\nThe output is creamed butter and sugar. This might not be the final product/exactly what you want if you are baking a cake but it is what you need for the next stage in the process.\r\nTwo main types of function:\r\nSub-functions\r\nSingle, modular units of code (collection of statements) that do a single isolated process.\r\n\r\nWrapper functions\r\nFunctions that call other sub-functions/processes to perform multiple linked processes together.\r\n\r\nHow to write and call a function\r\n\r\n\r\n##### Standard syntax\r\nfunction_name <- function(argument) {\r\n  code\r\n}\r\n\r\n# If you don't want to assign the output of the function to a variable:\r\nfunction_name(argument = \"value\")\r\nfunction_name(\"value\")\r\n\r\n# If you want to assign the output of the function to a variable:\r\nfunction_output <- function_name(argument = \"value\")\r\nfunction_output <- function_name(\"value\")\r\n\r\n\r\nreturn()\r\nIn the syntax above, I have just used code as a stand in for the body of the function.\r\nWhen running a function, the code chunk will run, but only the last line will be output into the environment/saved when assigned to a variable. Some like to explicitly use return() to show what is being returned at the end of the function, but it is not necessary.\r\nAlso, print() statements will be output into the console.\r\nIt is worth being aware that any variables that are assigned inside a function, don’t automatically exist in the outside environment (can’t be retrieved after the function has run).\r\nWould recommend playing around with assignment with your functions.\r\nThere is a way to save more to the environment but that hasn’t been covered here.\r\n\r\n\r\nalphabet <- function() {\r\n  var_1 <- \"a\" # var_1 doesn't exist\r\n  var_2 <- \"b\" # is not output because it is\r\n  print(var_1) # because paste is used, var_1/a is output\r\n                  # but not saved when the variable is assigned \r\n  \"c\" # This is what is saved and assigned to the variable\r\n}\r\n\r\n\r\n\r\n\r\nalphabet()\r\n\r\n[1] \"a\"\r\n[1] \"c\"\r\n\r\n# The print is still printed to console, but what is the last line is not\r\nout <- alphabet()\r\n\r\n[1] \"a\"\r\n\r\n# The last line is saved into the environment in the \"out\" variable\r\nout\r\n\r\n[1] \"c\"\r\n\r\n# This doesn't exist outside the function, only within the function\r\n  # So cannot be retrieved\r\nvar_1\r\n\r\nError in eval(expr, envir, enclos): object 'var_1' not found\r\n\r\nCalling functions from packages\r\nBefore you can use a function that doesn’t exist in base r, you need to either:\r\nlibrary() the package that contains the function which loads the function into your environment\r\nor explicitly call the function from the package it is in using package_name::function_name()\r\nWe recommend using package_name::function_name() because it keeps your environment clearer and there is no potential confusion if there are multiple functions with the same name.\r\nPlus, it makes it easier for someone reading the code and to look into the correct documentation if necessary.\r\nThis works for existing/published packages or your own custom packages. However, for this training, as the functions aren’t packaged, we will rarely use that notation.\r\nSimple/Sub-Functions\r\n\r\n\r\n## Example 1: Addition\r\nsum_two_numbers <- function(number_1, number_2) {\r\n  number_1 + number_2\r\n}\r\n\r\nsum_two_numbers(10, 3)\r\n\r\n[1] 13\r\n\r\nsum_two_numbers(number_1 = 11, number_2 = 22)\r\n\r\n[1] 33\r\n\r\n## Example 2: Temperature Conversions\r\n# Fahrenheit to Celsius\r\ndegree_F_to_C <- function(temp_F) {\r\n  (temp_F - 32) * 5 / 9\r\n}\r\n\r\n# Freezing point of water\r\ndegree_F_to_C(32)\r\n\r\n[1] 0\r\n\r\n# Boiling point of water\r\ndegree_F_to_C(212)\r\n\r\n[1] 100\r\n\r\n# Celsius to Kelvin\r\ndegree_C_to_K <- function(temp_C) {\r\n  temp_C + 273.15\r\n}\r\n\r\n# Freezing point of water in Kelvin\r\ndegree_C_to_K(0)\r\n\r\n[1] 273.15\r\n\r\nWrapper Functions\r\nMost functions will be wrapper functions of some sort. They will use existing published functions and/or custom functions to do more complex operations.\r\n\r\n## Example 1: Addition\r\n\r\ndouble_sum_two_numbers <- function(number_1, number_2) {\r\n  sum_two_numbers(number_1, number_2) * 2\r\n}\r\n\r\ndouble_sum_two_numbers(6, 5)\r\n\r\n[1] 22\r\n\r\n## Example 2: Temperature Conversions\r\n\r\n# Can nest related functions to run one after another\r\n# Freezing point of water in Kelvin\r\ndegree_C_to_K(degree_F_to_C(32))\r\n\r\n[1] 273.15\r\n\r\n# Or combine the functions/processes into a single wrapper function\r\n# This looks like more effort/code lines, but calling it is easier,\r\n  # it reads easier and you can add more processes to the function,\r\n    # not just nest the two function\r\ndegree_F_to_K <- function(temp_F) {\r\n  temp_C <- degree_F_to_C(temp_F)\r\n  degree_C_to_K(temp_C)\r\n}\r\n\r\n# And you can nest it within the function, so it is short, clear, easy to call\r\ndegree_F_to_K_nested <- function(temp_F) {\r\n  degree_C_to_K(degree_F_to_C(temp_F))\r\n}\r\n\r\n# Freezing point of water in Kelvin\r\ndegree_F_to_K(32)\r\n\r\n[1] 273.15\r\n\r\ndegree_F_to_K_nested(32)\r\n\r\n[1] 273.15\r\n\r\nArguments\r\nBy default, R will match arguments in the order they are used to the order they are in the function syntax.\r\n\r\n\r\nsimple_function <- function(arg_1, arg_2) {\r\n  print(paste(arg_1, arg_2, sep = \" - \"))\r\n}\r\n\r\n# Note the first argument relates to arg_1 as the argument name was not specified\r\n  # And vice versa\r\nsimple_function(\"this will be first\", \"this will be second\")\r\n\r\n[1] \"this will be first - this will be second\"\r\n\r\n# Note the first argument relates to arg_2 as it is specified and vice versa\r\nsimple_function(arg_2 = \"this will not be first\", \r\n                arg_1 = \"this will not be second\")\r\n\r\n[1] \"this will not be second - this will not be first\"\r\n\r\n# Another example\r\nminus_number <- function(starting_value, take_away) {\r\n  starting_value - take_away\r\n}\r\n\r\nminus_number(10, 5)\r\n\r\n[1] 5\r\n\r\nminus_number(5, 10)\r\n\r\n[1] -5\r\n\r\n# This is the same because you are specifying the arguments\r\nminus_number(take_away = 10, starting_value = 5)\r\n\r\n[1] -5\r\n\r\nRequired arguments\r\nIf an argument that is used in the function is missing, it will error.\r\nHowever, R executes functions in a lazy fashion. If arguments not required in the function are missing, the function will still be executed. Even though it doesn’t error, best practice is to make sure only arguments used in the code body are included.\r\n\r\n\r\n## Example 1: Addition\r\n\r\n# Function has 3 arguments, even though only 2 are used\r\ndouble_sum_two_numbers_three <- function(number_1, number_2, number_3) {\r\n  sum_two_numbers(number_1, number_2) * 2\r\n}\r\n\r\n# All three arguments are provided, even though number3 isn't used, but no error\r\ndouble_sum_two_numbers_three(6, 94, 20)\r\n\r\n[1] 200\r\n\r\n# This takes these two arguments as the first two arguments and\r\n  # as number3 isn't used, it doesn't matter that it is missing\r\n    # Still no error\r\ndouble_sum_two_numbers_three(88, -4)\r\n\r\n[1] 168\r\n\r\n\r\n\r\n# Number_1 is missing and there is no default\r\ndouble_sum_two_numbers_three(number_2 = -5, number3 = 12)\r\n\r\nError in double_sum_two_numbers_three(number_2 = -5, number3 = 12): unused argument (number3 = 12)\r\n\r\nDefault arguments\r\nIn all the examples above, we have only used arguments that require user inputs.\r\nHowever, there will be some arguments which have a default value so they do not need to be user defined every time when calling the function.\r\nDefaults can be set when the argument rarely need changing when running the function.\r\nFor very bespoke functions, these defaults can be very specific to their use-case.\r\nCommon default arguments are:\r\nNA\r\nNULL\r\n“”\r\n“generic title”\r\nTRUE/FALSE\r\n\r\n\r\n## Example 1: Addition\r\n\r\ndouble_sum_two_numbers_default <- function(number_1, number_2 = 0) {\r\n  sum_two_numbers(number_1, number_2)*2\r\n}\r\n\r\n# Just doubles the given argument (takes it as number_1)\r\n  # as number_2 is 0 by default\r\ndouble_sum_two_numbers_default(33)\r\n\r\n[1] 66\r\n\r\n\r\n\r\n# This is still missing number_1 as only number_2 had a default so errors\r\ndouble_sum_two_numbers_default(number_2 = 33)\r\n\r\nError in sum_two_numbers(number_1, number_2): argument \"number_1\" is missing, with no default\r\n\r\n\r\n\r\n## Example 2: Temperature Conversions\r\n\r\n# Here the default is 32 degree F aka 0 degree C\r\ndegree_F_to_K_default <- function(temp_F = 32) {\r\n  degree_C_to_K(degree_F_to_C(temp_F))\r\n}\r\n\r\n# So to use the default, can leave arguments blank\r\ndegree_F_to_K_default()\r\n\r\n[1] 273.15\r\n\r\nPoll: Which of these function toplines has a default argument?\r\nfunction(first_name, surname) {\r\nfunction(age) {\r\nfunction(film_name, year = NA) {\r\nfunction(first_arg, default) {\r\nAnswer\r\nAssignment\r\nWhen assigning something inside a function, the object will not be saved to the external environment, so you cannot access it after the function has finished running.\r\nOnly the final printout of the function (or return()) or anything that is run in print() is run.\r\n\r\n\r\n##### Example 1: Addition\r\n\r\nsum_two_numbers_assign <- function(number_1, number_2) {\r\n  sum <- number_1 + number_2\r\n}\r\n\r\n# Nothing printed out\r\nsum_two_numbers_assign(number_1 = 1, number_2 = 6)\r\n\r\n##### Example 2: Temperature Conversions\r\n\r\ndegree_F_to_K <- function(temp_F) {\r\n  temp_C <- degree_F_to_C(temp_F)\r\n  degree_C_to_K(temp_C)\r\n}\r\n\r\n# Freezing water in Kelvin returns the output\r\ndegree_F_to_K(temp_F = 32)\r\n\r\n[1] 273.15\r\n\r\ndegree_F_to_K_assign <- function(temp_F) {\r\n  temp_C <- degree_F_to_C(temp_F)\r\n  temp_K <- degree_C_to_K(temp_C)\r\n}\r\n\r\n# Freezing water in Kelvin will now not print the output\r\ndegree_F_to_K_assign(temp_F = 32)\r\n\r\n\r\nOrder of arguments for existing and own functions\r\nAs seen in previous examples, if no argument names are given, the function takes arguments in the order they are given.\r\nWhen writing your own (and is seen in most published functions), first should always be data.\r\nThis is especially important when using in dplyr pipes.\r\nUnfortunately, there are some older cases where that may not be the case, so it may be worth checking before you use them.\r\nMore information about this can be found in the piping section.\r\nINTRO BREAKOUT ROOMS\r\nWe will now go into breakout rooms to try some exercises.\r\nFunction syntax (how its written)\r\nDefault arguments\r\nBest Practice Style of Function\r\nThere are many ways that you could write a function that technically would work.\r\nCode within a function should follow standard best practice style (see Tidyverse Style Guide).\r\nHowever, there are some best practice guidance to follow.\r\nKey point regardless of style you choose to follow: Consistency.\r\nNote: Packages exist to help you adhere to best style.\r\nWe recommend lintr. It doesn’t edit your code directly (as some others do, e.g. styler) but makes a descriptive list of where it recommends style improvements.\r\nThis package may not be perfect and is not a replacement for writing good code in the first place, or being critical about style in general.\r\n\r\n\r\ninstall.packages(\"lintr\")\r\n# This is the main function to check style in R scripts. Others exist too.\r\nlintr::lint(\"filename_filepath.R\")\r\n\r\n\r\nFunction name\r\nsnake_case\r\nLower case, numbers and underscores only (no full stops or hyphens)\r\nWords separated with _\r\n\r\nVery descriptive/meaningful\r\nIdeally contain a verb\r\nDoesn’t overwrite a commonly used/base function\r\nDo not start with a number or underscore\r\nLines\r\nIf the lines get too long (>79 characters), you can put the arguments on separate lines.\r\nCurly brackets: { should be the last thing on its line, } should be the first thing on its line.\r\nCode should be between the { and }, not on the same line.\r\nSpacing\r\nSpaces around the assignment (=, <-)\r\nSpace after comma in list of arguments\r\nNo space between function and (\r\nNo space between ( and first argument\r\nNo space between final argument and )\r\nSpace between ) and {\r\nIndentation\r\nCode should be indented 2 spaces (plus any further indents depending on the code).\r\nCtrl+i in RStudio manages this indentation for you.\r\nReturns\r\nR doesn’t need an explicit return().\r\nThe last line (idea/phrase) of a function is automatically returned.\r\nTidyverse style guide suggests not including the return(), but it has been used in some examples for clarity.\r\nConsistency is key.\r\nFurthermore, anything that is inside print() and warnings/errors will be returned to the console, but not saved as an output of the function.\r\nAssignment\r\nUse = inside a functions arguments (i.e. defining a default argument and specifying an argument when calling it).\r\nUse <- as normal best-practice inside the function code.\r\nArguments\r\nArgument names should follow similar rules to function names:\r\nDescriptive\r\nsnake_case\r\nConsistent argument names across functions can be helpful (e.g. df for a dataframe argument, x for an integer)\r\nLower case, numbers and underscores only (no full stops or hyphens)\r\nDo not start with a number or underscore\r\nIf the argument requires a string, use “string”, rather than ‘string’.\r\nUnless there is quote within a string: ‘this is a “quote” string’.\r\nFor general arguments, you don’t have to explicitly name the most obvious arguments (e.g. data) but it is recommended for custom functions and especially optional arguments. It can be very helpful for clarity in complex pipelines.\r\nComments\r\nIf using docstrings, minimal comments should be necessary for sub-functions.\r\nOnly comments explaining why things are being done should be included, instead of what is being done (same as general commenting style).\r\nIf docstrings are not used, should still add general comments on the function. At least for a title, description, any parameters and what is returned.\r\nPiping %>% style/dplyr (Advanced)\r\nThis relates to pipes (%>%) in code within and outside of functions.\r\n\r\n\r\n# If there is only one dplyr function, no pipes\r\ndplyr::filter(iris, Petal.Length > 6.5)\r\n\r\n  Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\r\n1          7.6         3.0          6.6         2.1 virginica\r\n2          7.7         3.8          6.7         2.2 virginica\r\n3          7.7         2.6          6.9         2.3 virginica\r\n4          7.7         2.8          6.7         2.0 virginica\r\n\r\n# If there are pipes, only one pipe per line and it is the last thing on the line\r\niris %>%\r\n  dplyr::filter(Petal.Length > 6.5) %>%\r\n  dplyr::select(Species, Petal.Length, Petal.Width)\r\n\r\n    Species Petal.Length Petal.Width\r\n1 virginica          6.6         2.1\r\n2 virginica          6.7         2.2\r\n3 virginica          6.9         2.3\r\n4 virginica          6.7         2.0\r\n\r\nPoll: R best practice function and argument names?\r\nDoctorHouse(Patient1, Patient2)\r\ndoctorHouse(1stpatient, 2ndpatient)\r\ndoctorhouse(patientone, patienttwo)\r\ndoctor_house(first_patient, second_patient)\r\nAnswer\r\nDocumentation (docstrings)\r\nEven if you don’t do technical Roxygen headers, you should still have correct level of comments describing what the function does: a title, description, any parameters and what is returned.\r\nHowever, we recommend giving any custom function the below Roxygen structure as it adds consistency, readability and can save time if you decide to package in the future.\r\nFunction documentation: roxygen2\r\nStandard format of headers to add to functions that automate creation of the function documentation.\r\nIn RStudio, put the cursor inside the function and either:\r\nCtrl+Shift+Alt+R\r\nOn toolbar, Code → Insert Roxygen skeleton\r\nSome parts are required, some are optional.\r\nRequired:\r\nTitle\r\nLike a short description\r\n\r\nDescription\r\nFull sentence structure explanation of what the function does and any important contextual information\r\n\r\nParameters\r\nShould have a descriptive name\r\nInclude what type/class of object is needed\r\nInclude any default values\r\n\r\nReturn\r\nWhat is the expected output (inc type/class)\r\n\r\nOptional:\r\nExamples\r\nCan add code for full, workable examples of the function to the header to help people use it\r\n\r\nAuthor\r\nAdd the authors name to the function\r\n\r\nExport\r\nAllows the function to be called one the function is packaged\r\n\r\nImport\r\nAny packages that need to be imported to the function to allow sub-functions to work\r\n\r\nThere are many other optional tags.\r\nNote: Best practice is to put sub-functions below the wrapper where it is used.\r\n\r\n\r\n##### Example 1 - Addition #####\r\n\r\n#' Sums two numbers\r\n#' \r\n#' @description Adds two numbers together and returns the sum.\r\n#' The numeric vectors need to be a multiple of each other (or the same).\r\n#'\r\n#' @param number_1 numeric vector\r\n#' @param number_2 numeric vector\r\n#'\r\n#' @return integer\r\nsum_two_numbers <- function(number_1, number_2) {\r\n  number_1 + number_2\r\n}\r\n\r\n##### Example 2 - Temperature Conversions #####\r\n\r\n#' Converts degrees Fahrenheit to degrees Celsius\r\n#'\r\n#' @description Converts degrees Fahrenheit to degrees Celsius,\r\n#' can be used on single number or numeric vector\r\n#' \r\n#' @param temp_F numeric vector of temperature in Fahrenheit\r\n#'\r\n#' @return numeric vector of temperature in Celsius\r\ndegree_F_to_C <- function(temp_F) {\r\n  (temp_F - 32) * 5 / 9\r\n}\r\n\r\n#' Converts degrees Fahrenheit to Kelvin\r\n#'\r\n#' @description Converts degrees Fahrenheit to Kelvin,\r\n#' can be used on single number or numeric vector\r\n#'\r\n#' @param temp_F numeric vector of temperature in Fahrenheit\r\n#'\r\n#' @return numeric vector of temperature in Kelvin\r\ndegree_F_to_K <- function(temp_F) {\r\n  temp_C <- degree_F_to_C(temp_F)\r\n  degree_C_to_K(temp_C)\r\n}\r\n\r\n#' Converts degrees Celsius to Kelvin\r\n#'\r\n#' @description Converts degrees Fahrenheit to Kelvin, \r\n#' can be used on single number or numeric vector\r\n#'\r\n#' @param temp_C numeric vector of temperature in Celsius\r\n#'\r\n#' @return numeric vector of temperature in Kelvin\r\ndegree_C_to_K <- function(temp_C) {\r\n  temp_C + 273.15\r\n}\r\n\r\n\r\nRoxygen creates the standard help documentationPoll: Which are the required parts of Roxygen header?\r\nTitle, description, parameters, return\r\nTitle, example, return\r\nTitle, parameters, return, example\r\nDescription, parameters, example\r\nAnswer\r\nPiping %>%\r\nThe pipe operator %>% (originally found in package magrittr) can be used as “and then” to call functions sequentially. It is most commonly found connecting dplyr functions together.\r\nThis replaces the need to save out intermediate results or nest functions.\r\nThese all do the same thing:\r\n\r\n\r\n# Make random vector\r\nx <- runif(100)\r\n\r\n# Intermediate saving - Should be avoided as much as possible\r\nout <- sd(x)\r\nout <- mean(out)\r\nsqrt(out)\r\n\r\n[1] 0.5179677\r\n\r\n# Nesting - Can get complicated when there are multiple arguments and brackets\r\nsqrt(mean(sd(x)))\r\n\r\n[1] 0.5179677\r\n\r\n# Piping - Best Practice\r\nx %>%\r\n  sd() %>%\r\n  mean() %>%\r\n  sqrt()\r\n\r\n[1] 0.5179677\r\n\r\nAs mentioned in a previous section, the order of arguments for dplyr piping is quite important. Data should be the first.\r\nWhen the functions are called in a pipe, it is assumed that the data from the previous level of the pipe is the default first argument, so it doesn’t need to be specified in each function.\r\n\r\n\r\n# Using a pre-loaded example dataset called iris\r\nhead(iris)\r\n\r\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\r\n1          5.1         3.5          1.4         0.2  setosa\r\n2          4.9         3.0          1.4         0.2  setosa\r\n3          4.7         3.2          1.3         0.2  setosa\r\n4          4.6         3.1          1.5         0.2  setosa\r\n5          5.0         3.6          1.4         0.2  setosa\r\n6          5.4         3.9          1.7         0.4  setosa\r\n\r\nselect_species_petal_width <- function(data, species_interest, petal_width) {\r\n\r\n  data %>%\r\n    dplyr::filter(Species == species_interest) %>%\r\n    dplyr::filter(Petal.Width < petal_width)\r\n  # These two filters do not have to be on separate lines \r\n    # but here they are split to demonstrate multiple pipes\r\n}\r\n\r\n\r\nhead(select_species_petal_width(iris, \"versicolor\", 1.5), 10)\r\n\r\n   Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\r\n1           7.0         3.2          4.7         1.4 versicolor\r\n2           5.5         2.3          4.0         1.3 versicolor\r\n3           5.7         2.8          4.5         1.3 versicolor\r\n4           4.9         2.4          3.3         1.0 versicolor\r\n5           6.6         2.9          4.6         1.3 versicolor\r\n6           5.2         2.7          3.9         1.4 versicolor\r\n7           5.0         2.0          3.5         1.0 versicolor\r\n8           6.0         2.2          4.0         1.0 versicolor\r\n9           6.1         2.9          4.7         1.4 versicolor\r\n10          5.6         2.9          3.6         1.3 versicolor\r\n\r\nYou can combine custom functions with existing functions, but you must be aware of the data argument. You may need to explicitly define that the data is to be used, using: ., followed by a comma to separate it from the next argument.\r\n\r\n\r\niris %>%\r\n  select_species_petal_width(\"versicolor\", 1.5) %>%\r\n  dplyr::mutate(sepal_width_to_length = Sepal.Width / Sepal.Length) %>%\r\n  utils::head(.)\r\n\r\n  Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\r\n1          7.0         3.2          4.7         1.4 versicolor\r\n2          5.5         2.3          4.0         1.3 versicolor\r\n3          5.7         2.8          4.5         1.3 versicolor\r\n4          4.9         2.4          3.3         1.0 versicolor\r\n5          6.6         2.9          4.6         1.3 versicolor\r\n6          5.2         2.7          3.9         1.4 versicolor\r\n  sepal_width_to_length\r\n1             0.4571429\r\n2             0.4181818\r\n3             0.4912281\r\n4             0.4897959\r\n5             0.4393939\r\n6             0.5192308\r\n\r\nWarnings and Errors\r\nIt can often be useful to add warnings and errors into your functions to help usability. Combine conditionals (if, else, ifelse or dplyr::case_when e.t.c.) with warnings/errors to only show in certain cases.\r\nUsing paste (or paste0) allows crafting of bespoke warning/error messages, such as what case you are testing.\r\nWarnings\r\nDoesn’t stop the code from running, but prints the warning to the console.\r\n\r\n\r\ndegree_F_to_C <- function(temp_F) {\r\n  if (temp_F < -460) {\r\n    warning(paste(\"Provided temperature (\",\r\n                  temp_F,\r\n                  \") is below absolute zero and thus, is impossible.\"))\r\n  }\r\n  (temp_F - 32) * 5 / 9\r\n}\r\n\r\ndegree_F_to_C(-666)\r\n\r\n[1] -387.7778\r\n\r\nErrors\r\nWill stop the code running at that point and print the error to the console.\r\n\r\n\r\ndegree_F_to_C <- function(temp_F) {\r\n  if (class(temp_F) != \"numeric\") {\r\n    stop(paste(\"Provided temperature in fahrenheit is not numeric. It is a\",\r\n               class(temp_F), \r\n               \"object.\"))\r\n  }\r\n  (temp_F - 32) * 5 / 9\r\n}\r\n\r\ndegree_F_to_C(\"200\")\r\n\r\nError in degree_F_to_C(\"200\"): Provided temperature in fahrenheit is not numeric. It is a character object.\r\n\r\nPoll: What are the correct functions to create a warning and an error? (click 2 answers)\r\nerror()\r\nstop()\r\nwarnings()\r\nSOMETHING_IS_VERY_WRONG()\r\nhalt()\r\nwarning()\r\nAnswer\r\nINTRO BREAKOUT ROOMS\r\nWe will now go into breakout rooms to try some exercises.\r\nGood style and naming-conventions\r\nRoxygen documentation\r\nADVANCED BREAKOUT ROOMS\r\nStyle\r\nDefault arguments\r\nRoxygen doc\r\nExercises 1 and 2 from part 2.\r\nIntermediate/Advanced Functions\r\nClick here to return to Intro.\r\nLists of functions\r\nThe best way to group functions together is using packages.\r\nIf you are not going to build a package for your functions, a simple way to group similar/related functions together is to combine them into a list (remember, functions are objects).\r\nYou then call them the same way that you would call a list element.\r\nThis is not generally recommended.\r\n\r\n\r\nfunction_list <- list(\r\n  half_num = function(x) x / 2,\r\n  double_num = function(x) x * 2\r\n)\r\n\r\nfunction_list$double_num(10)\r\n\r\n[1] 20\r\n\r\nFunctionals\r\nThe apply family of functions (lapply(), sapply(), vapply()) can be used within bespoke functions or used to apply bespoke functions, not just regular functions.\r\n\r\n\r\nvector <- c(1, NA, 3, 4, 5)\r\ndataframe <- data.frame(col1 = c(NA, NA, 6, 8),\r\n                        col2 = c(2, 4, NA, 9))\r\n\r\ndata_list <- list(vector, dataframe)\r\n\r\n## lapply for a bespoke function\r\n\r\ncut_in_half <- function(data) {\r\n  data / 2\r\n}\r\n\r\ncut_in_half(vector)\r\n\r\n[1] 0.5  NA 1.5 2.0 2.5\r\n\r\ncut_in_half(dataframe)\r\n\r\n  col1 col2\r\n1   NA  1.0\r\n2   NA  2.0\r\n3    3   NA\r\n4    4  4.5\r\n\r\nlapply(data_list, cut_in_half)\r\n\r\n[[1]]\r\n[1] 0.5  NA 1.5 2.0 2.5\r\n\r\n[[2]]\r\n  col1 col2\r\n1   NA  1.0\r\n2   NA  2.0\r\n3    3   NA\r\n4    4  4.5\r\n\r\n\r\n\r\n## lapply inside function\r\n\r\ncut_list_in_half <- function(list) {\r\n  lapply(list, cut_in_half)\r\n}\r\n\r\ncut_list_in_half(data_list)\r\n\r\n[[1]]\r\n[1] 0.5  NA 1.5 2.0 2.5\r\n\r\n[[2]]\r\n  col1 col2\r\n1   NA  1.0\r\n2   NA  2.0\r\n3    3   NA\r\n4    4  4.5\r\n\r\nAnonymous functions\r\nNot all functions need to be named. Small (one-line) functions that are not worth naming are called anonymous functions.\r\nA good rule of thumb is that an anonymous function should fit on one line and shouldn’t need to use {}.\r\n\r\n\r\nsapply(starwars, function(x) length(unique(x)))\r\n\r\n      name     height       mass hair_color skin_color  eye_color \r\n        87         46         39         13         31         15 \r\nbirth_year        sex     gender  homeworld    species      films \r\n        37          5          3         49         38         24 \r\n  vehicles  starships \r\n        11         17 \r\n\r\n# Keeps only non-numeric columns\r\nhead(Filter(function(x) !is.numeric(x), starwars))\r\n\r\n# A tibble: 6 x 11\r\n  name      hair_~1 skin_~2 eye_c~3 sex   gender homew~4 species films\r\n  <chr>     <chr>   <chr>   <chr>   <chr> <chr>  <chr>   <chr>   <lis>\r\n1 Luke Sky~ blond   fair    blue    male  mascu~ Tatooi~ Human   <chr>\r\n2 C-3PO     <NA>    gold    yellow  none  mascu~ Tatooi~ Droid   <chr>\r\n3 R2-D2     <NA>    white,~ red     none  mascu~ Naboo   Droid   <chr>\r\n4 Darth Va~ none    white   yellow  male  mascu~ Tatooi~ Human   <chr>\r\n5 Leia Org~ brown   light   brown   fema~ femin~ Aldera~ Human   <chr>\r\n6 Owen Lars brown,~ light   blue    male  mascu~ Tatooi~ Human   <chr>\r\n# ... with 2 more variables: vehicles <list>, starships <list>, and\r\n#   abbreviated variable names 1: hair_color, 2: skin_color,\r\n#   3: eye_color, 4: homeworld\r\n# i Use `colnames()` to see all variable names\r\n\r\n# Integrates x to the power of 2 using limits of 0 and 10\r\nintegrate(function(x) x ^ 2, 0, 10)\r\n\r\n333.3333 with absolute error < 3.7e-12\r\n\r\nFunctions with Dynamic Arguments\r\nUsing base r and dplyr Function Tidy Evaluation\r\nSome variables, commonly column names, can be dependent on some external factor (e.g. user input, data values) and you may want to manipulate them in a generic way in using function arguments. This can commonly happen when you want to choose the column of interest manually in a function or when iterating/looping through.\r\nThis can be done with base r, using variable selection such as square brackets [] and double square brackets [[]].\r\nFor example, using base r:\r\n\r\n\r\ncolour_data <- data.frame(red = c(1, 2, 3),\r\n                          blue = c(5, 7, 3),\r\n                          green = c(9, 8, 7))\r\n\r\n# I want to get the mean of one column of my choice.\r\n\r\ncol_mean <- function(data, col) {\r\n  print(paste0(col, \": \", mean(data[[col]])))\r\n}\r\n\r\ncol_mean(colour_data, \"blue\")\r\n\r\n[1] \"blue: 5\"\r\n\r\n# I want to iterate through the columns using a vector\r\n\r\ncol_vector <- c(\"green\", \"blue\", \"red\")\r\n\r\nfor (colour in col_vector) {\r\n  col_mean(colour_data, colour)\r\n}\r\n\r\n[1] \"green: 8\"\r\n[1] \"blue: 5\"\r\n[1] \"red: 2\"\r\n\r\nSome people prefer to structure their code following tidyverse styling.dplyr provides a way to dynamically manipulate columns, but it makes writing functions containing dplyr functions a bit more complicated.\r\nEnvironmental variables vs data variables\r\nTo determine the syntax to use, you need to remember the distinction between data and environmental variables and which dplyr function uses which.\r\nEnv-variables are “programming” variables that live in an environment, usually created with <-, can be seen in the RStudio Environment window.\r\nData-variables are “statistical” variables that live in a data frame (generally columns).\r\nUse ?dplyr::function() to see which type of formatting the variable uses: data masking or tidy selection.\r\nQuoted vs unquoted variables\r\nThe syntax for dynamic arguments in dplyr are dependent on if the variable (column name) is quoted (a string) or unquoted (not a string).\r\nIt is possible to convert between the two but that gets even more complicated.\r\n\r\n\r\ndf <- data.frame(column_one = c(seq(1, 5, 1)),\r\n                 column_two = c(seq(6, 10, 1)))\r\ncolname <- \"column_one\"\r\n\r\n## Base using the known column name unquoted and quoted\r\ndf$column_one\r\n\r\n[1] 1 2 3 4 5\r\n\r\ndf$\"column_one\"\r\n\r\n[1] 1 2 3 4 5\r\n\r\ndf[, \"column_one\"]\r\n\r\n[1] 1 2 3 4 5\r\n\r\n## Base with a variable column name\r\ndf[[colname]]\r\n\r\n[1] 1 2 3 4 5\r\n\r\ndf[, colname]\r\n\r\n[1] 1 2 3 4 5\r\n\r\n# Doesn't work\r\ndf$colname\r\n\r\nNULL\r\n\r\ndf$\"colname\"\r\n\r\nNULL\r\n\r\ndf[[\"colname\"]]\r\n\r\nNULL\r\n\r\n## dplyr can use unquoted and quoted column names\r\ndplyr::pull(df, column_one)\r\n\r\n[1] 1 2 3 4 5\r\n\r\ndplyr::pull(df, colname)\r\n\r\n[1] 1 2 3 4 5\r\n\r\n## But when you use dplyr functions inside bespoke functions\r\n  # It works like normal if you statically define the column name\r\npull_col_one <- function(data) {\r\n  dplyr::pull(data, column_one)\r\n}\r\npull_col_one(df)\r\n\r\n[1] 1 2 3 4 5\r\n\r\npull_col_one <- function(data) {\r\n  dplyr::pull(data, \"column_one\")\r\n}\r\npull_col_one(df)\r\n\r\n[1] 1 2 3 4 5\r\n\r\n# It becomes more complicated when you want to chose the column with an argument\r\n  # This doesn't work\r\npull_colname <- function(data, column_name) {\r\n  dplyr::pull(data, column_name)\r\n}\r\npull_colname(df, column_one)\r\n\r\nError in `dplyr::pull()`:\r\nCaused by error:\r\n! object 'column_one' not found\r\n\r\nUnquoted\r\nThe variable is generally unquoted when you know what the column name is (i.e. you aren’t pulling it from somewhere else or creating it somehow). This requires external knowledge of the data.\r\nThis is how we use dplyr functions to access column names.\r\nQuoted\r\nQuoted/string variables are generally useful for when the column name is derived from something else in an automated way (e.g. using paste(), colnames() e.t.c.). Column names as strings are much easier to work with than unquoted, but the syntax for creating dynamic arguments is a bit more complicated. These string column names are more flexible as they can be manipulated with normal string manipulation.\r\nArguments\r\nWhen creating dplyr tidy evaluation functions, the first argument should be data.\r\nThen when you are piping with your custom functions, you do not need to give the data argument.\r\nFurther information can be found in dplyr documentation.\r\nData Masking\r\nApplies to:\r\nfilter()\r\ngroup_by()\r\nmutate()\r\nsummarise()\r\narrange()\r\ncount()\r\nCan use column names (i.e. data variables) as if they were variables in the environment, similar to how dplyr variables are called.\r\ni.e. you write column_name, not df$column_name or df[[column_name]]\r\nIf the variable is unquoted/not a string:\r\nNeed to double-embrace it with curly brackets {{variable}} where it is used in the body of the function.\r\nAlso, can use glue syntax with := to name the resulting variables after the unquoted argument variable contained in double curly brackets {{}}.\r\n\r\n\r\ngroup_count_min_max <- function(df, group_var, summ_var) {\r\n  df %>%\r\n    dplyr::group_by({{group_var}}) %>%\r\n    dplyr::summarise(\"n_{{summ_var}}\" := n(),\r\n                     \"min_{{summ_var}}\" := min({{summ_var}}),\r\n                     \"max_{{summ_var}}\" := max({{summ_var}}))\r\n}\r\n\r\ngroup_count_min_max(df = mtcars, group_var = cyl, summ_var = mpg)\r\n\r\n# A tibble: 3 x 4\r\n    cyl n_mpg min_mpg max_mpg\r\n  <dbl> <int>   <dbl>   <dbl>\r\n1     4    11    21.4    33.9\r\n2     6     7    17.8    21.4\r\n3     8    14    10.4    19.2\r\n\r\n# If piping, so long as your first argument of your custom function is the data,\r\n  # you don't need to specify the data using a full-stop\r\n# Can pipe the custom function along with other dplyr functions\r\nmtcars %>%\r\n  dplyr::select(-gear) %>%\r\n  group_count_min_max(group_var = cyl, summ_var = mpg)\r\n\r\n# A tibble: 3 x 4\r\n    cyl n_mpg min_mpg max_mpg\r\n  <dbl> <int>   <dbl>   <dbl>\r\n1     4    11    21.4    33.9\r\n2     6     7    17.8    21.4\r\n3     8    14    10.4    19.2\r\n\r\n## This is much more complicated to do in base\r\n\r\n\r\nIf the variable is quoted/a string:\r\nIf a variable exists as a character string (i.e. as an env-variable), need to indirectly select it from .data in the body of the function where it is used using [[]].\r\nThe .data bit does not vary with different argument names, it is always the .data as it refers to the data within the pipe level above.\r\nCan also use glue syntax with := to name the resulting variables after the quoted argument variable (embraced by single curly brackets {}).\r\n\r\n\r\ngroup_count_min_max <- function(df, group_var, summ_var) {\r\n  df %>%\r\n    dplyr::group_by(.data[[group_var]]) %>%\r\n    dplyr::summarise(\"n_{summ_var}\" := n(),\r\n                     \"min_{summ_var}\" := min(.data[[summ_var]]),\r\n                     \"max_{summ_var}\" := max(.data[[summ_var]]))\r\n}\r\n\r\nmtcars %>%\r\n  group_count_min_max(group_var = \"cyl\", summ_var = \"mpg\")\r\n\r\n# A tibble: 3 x 4\r\n    cyl n_mpg min_mpg max_mpg\r\n  <dbl> <int>   <dbl>   <dbl>\r\n1     4    11    21.4    33.9\r\n2     6     7    17.8    21.4\r\n3     8    14    10.4    19.2\r\n\r\nTidy Selection\r\nApplies to:\r\nselect()\r\nacross()\r\nrename()\r\nrelocate()\r\npull()\r\nCan easily choose variables based on their position, name or type.\r\ne.g. starts_with(\"x\") or is.numeric()\r\nIf the variable is unquoted:\r\nSimilar to data masking, you can use embracing with double curly brackets {{}}.\r\n\r\n\r\ndrop_rename_iris <- function(data, drop_var, chosen_var) {\r\n  data %>%\r\n    dplyr::select(-{{drop_var}}) %>%\r\n    dplyr::rename(var_of_interest = {{chosen_var}})\r\n}\r\n\r\niris %>%\r\n  drop_rename_iris(drop_var = Sepal.Length,\r\n                   chosen_var = Species) %>%\r\n  head()\r\n\r\n  Sepal.Width Petal.Length Petal.Width var_of_interest\r\n1         3.5          1.4         0.2          setosa\r\n2         3.0          1.4         0.2          setosa\r\n3         3.2          1.3         0.2          setosa\r\n4         3.1          1.5         0.2          setosa\r\n5         3.6          1.4         0.2          setosa\r\n6         3.9          1.7         0.4          setosa\r\n\r\nIf the variable is quoted:\r\nSimilar to data masking, can use indirect selection from .data using [[]].\r\n\r\n\r\ndrop_rename_iris <- function(data, drop_var, chosen_var) {\r\n  data %>%\r\n    dplyr::select(-.data[[drop_var]]) %>%\r\n    dplyr::rename(var_of_interest = .data[[chosen_var]])\r\n}\r\n\r\niris %>%\r\n  drop_rename_iris(drop_var = \"Sepal.Length\",\r\n                   chosen_var = \"Species\") %>%\r\n  head()\r\n\r\n  Sepal.Width Petal.Length Petal.Width var_of_interest\r\n1         3.5          1.4         0.2          setosa\r\n2         3.0          1.4         0.2          setosa\r\n3         3.2          1.3         0.2          setosa\r\n4         3.1          1.5         0.2          setosa\r\n5         3.6          1.4         0.2          setosa\r\n6         3.9          1.7         0.4          setosa\r\n\r\n# As seen in the warning above, it appears that .data[[var]] \r\n  # has now been depreciated\r\n\r\ndrop_rename_iris <- function(data, drop_var, chosen_var) {\r\n  data %>%\r\n    dplyr::select(-all_of(drop_var)) %>%\r\n    dplyr::rename(var_of_interest = .data[[chosen_var]])\r\n}\r\n\r\niris %>%\r\n  drop_rename_iris(drop_var = \"Sepal.Length\",\r\n                   chosen_var = \"Species\") %>%\r\n  head()\r\n\r\n  Sepal.Width Petal.Length Petal.Width var_of_interest\r\n1         3.5          1.4         0.2          setosa\r\n2         3.0          1.4         0.2          setosa\r\n3         3.2          1.3         0.2          setosa\r\n4         3.1          1.5         0.2          setosa\r\n5         3.6          1.4         0.2          setosa\r\n6         3.9          1.7         0.4          setosa\r\n\r\n## More advanced example\r\n\r\ndf <- data.frame(index_partial = sample(0:1, size = 100, replace = TRUE),\r\n                 index_all = sample(0:1, size = 100, replace = TRUE),\r\n                 days_partial = sample(x = 0:100, size = 100),\r\n                 days_all = sample(x = 0:100, size = 100))\r\n\r\nmean_day <- function(var_name) {\r\n  df %>%\r\n    dplyr::filter(.data[[paste0(\"index_\", var_name)]] == 1) %>%\r\n    dplyr::summarise(\"mean_days_{ var_name }\" := \r\n                       mean(.data[[paste0(\"days_\", var_name)]], na.rm = TRUE))\r\n}\r\n\r\nmean_day(\"partial\")\r\n\r\n  mean_days_partial\r\n1          50.98113\r\n\r\nPoll: How do you select a variable in a function with data masking?\r\nunquoted: {var} quoted: [var]\r\nquoted: {var} unquoted: [var]\r\nunquoted: {{var}} quoted: .data[[var]]\r\nquoted: {{var}} unquoted: .data[[var]]\r\nADVANCED BREAKOUT ROOMS\r\nBase vs dplyr dynamic data selection.\r\nExercises 3 and 4.\r\nPoll Answers\r\nWhich of these function top lines has a default argument?function(film_name, year = NA) {\r\nR best practice function and argument names?doctor_house(first_patient, second_patient)\r\nWhich are the required parts of Roxygen header?\r\nTitle, description, parameters, return\r\nWhat are the correct functions to create a warning and an error?\r\nstop()\r\nwarning()\r\nHow do you select a variable in a function with data masking?\r\nunquoted: {{var}} quoted: .data[[var]]\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-25T13:44:07+01:00"
    },
    {
      "path": "index.html",
      "title": "RAPID training",
      "description": "Training materials for building Reproducible Analytical Pipelines\n",
      "author": [],
      "contents": "\r\nWhat is RAP and why should it be implemented.\r\nSee RAP in R for training resources for R and R Studio.\r\nAdd links to other useful sites: ASAP, analysis function, NHSD Python repo.\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-25T13:44:09+01:00"
    },
    {
      "path": "packages.html",
      "title": "Packages and unit testing in R",
      "author": [],
      "contents": "\r\n\r\nContents\r\nWhat is a package and when do we need one?\r\nPrerequisities\r\nPackage structure and setup\r\nPackage name\r\nCreating basic structure\r\n\r\nFunctions and installing/testing your package\r\nAdding functions to your package\r\nTrying out functions from your package\r\nPackage exercises - building a package\r\n\r\nPackage documentation\r\nMinimum functionality and installing your package\r\nFunctions’ docstrings\r\nExample roxygen docstrings\r\nOptional roxygen tags (advanced content)\r\nProduce documentation\r\nDocumentation exercises\r\n\r\nUnit testing and Quality Assurance\r\nWhat are unit tests?\r\nWhere to put unit tests in a package?\r\nHow to write unit tests with testthat?\r\nWhat should you be testing?\r\nHow many tests for a function? (optional)\r\nTesting your package\r\nUnExported functions (optional)\r\nQuality Assurance\r\nTesting excercises\r\n\r\nHow to share your package?\r\nAdditional resources\r\n\r\nWhat is a package and when do we need one?\r\nTo put simply a package is a collection of functions that we can load into our workspace and use. Base R contains many functions already, but loading packages extends R functionality. Some of the most popular packages in HAPI include dplyr for data manipulation and ggplot2 for creating charts.\r\nIs a package only way to store and load your functions? No. Depending on the size and complexity of your project you should select one of the following options to store your functions.\r\nSimplest option is to have functions stored in the body of your scipt, load them into the global environment (you’ll see them in the top right corner in R Studio) and use. This will only be good solution for a very small project.\r\nYou can save all of your functions in a single .R script (e.g. “functions.R”) and load them in into analytical script using source() function e.g.:\r\n\r\n\r\nsource(\"functions.R\")\r\n\r\n\r\nYou can create a package that will contain all your functions. Benefits of that solution include good dependency management (using other packages, requiring specific versions etc.), simple implementation of unit tests and good documentation solutions that make it easier for other people to use your functions. Package is often the best solution for more complex analyses.\r\nQ1\r\nPrerequisities\r\nYou will need devtools and roxygen packages installed for this tutorial.\r\n\r\n\r\ninstall.packages(c(\"devtools\", \"roxygen\"), dependencies = TRUE, type = \"win.binary\")\r\n\r\n\r\nPackage structure and setup\r\nPackage name\r\nPackage name should consist of letters and numbers and be informative. You can’t use underscores in a package name, but . are allowed. Make sure that your name is unique to avoid conflicts with existing packages.\r\nCreating basic structure\r\nDevtools create() function creates package folders in current directory.\r\n\r\n\r\ndevtools::create(\"pckgname\")\r\n\r\n\r\nThe structure created this way includes folder called R (for all your functions) and DESCRIPTION and NAMESPACE files.\r\n\r\n\r\ndir(\"pckgname\")\r\n\r\n[1] \"DESCRIPTION\" \"NAMESPACE\"   \"R\"          \r\n\r\nDESCRIPTION file can be edited manually (e.g. using notepad) and should contain:\r\nTitle of the package\r\nAny dependencies, including versions (if needed)\r\nLicense\r\nAuthors@R field should include details of authors, contributors, and copyright holders\r\nNAMESPACE file should not be edited manually, it will be updated automatically when you document your package.\r\nThis a basic structure of a package. In analytical pipeline, your package is something that stores all the functions (can store few more things as you will see later), but does not include the main pipeline itself. Your overall project structure will look as follows:\r\nproject/\r\n  pckgname/\r\n    DESCRIPTION\r\n    NAMESPACE\r\n    R/\r\n      analytical_functions.R\r\n      data_processing_functions.R\r\n      super_complex_modelling_functions.R\r\n\r\n  README.txt\r\n  config.yaml OR config.R\r\n  main.R\r\nThis is the basic package structure, there will be few more things in the package that you’ll learn about in the further sections.\r\nQ5\r\nFunctions and installing/testing your package\r\nAdding functions to your package\r\nFunctions need to be stored in R/ folder inside the package. You can have individual files for each function or store multiple functions in a single file. Files containing a single function should have the same name as that function. When you store couple of functions together they should be grouped with similar functions (e.g. import functions) and files should have informative names (e.g. data_import.R). The easiest way to add functions to a package is to create an R script and save it in the project/pckgname/R folder.\r\nYou can simply open a new R script, name it cool_functions.R and save in your /R subfolder inside the package folder. You can also create new R script using:\r\n\r\n\r\nsetwd(\"pckgname\") # you need to be in the package folder -> so first we move into the package\r\nusethis::use_r(\"cool_functions\")    # creates and opens R/cool_functions.R\r\n\r\n\r\n*Note that using setwd() in a chunk only works within that chunk. So your wd outside the chunk stays the same - and other chunks are going to use the global working directory instead.\r\nYou can paste in the following function or create your own.\r\n\r\n\r\nadd_3 <- function(x) {\r\n  x + 3\r\n}\r\n\r\n\r\nTrying out functions from your package\r\nNow that we have something in our package, let’s try installing it. To do so you need to be in your project directory (e.g. “D:/project/”) if you aren’t use setwd(“D:/project/”) in R console to change your working directory.\r\nTo install your package:\r\n\r\n\r\ndevtools::install(\"pckgname\")\r\n\r\n  \r\n  \r\n  \r\n   checking for file 'D:\\github\\web_raptraining\\pckgname/DESCRIPTION' ...\r\n  \r\nv  checking for file 'D:\\github\\web_raptraining\\pckgname/DESCRIPTION' (722ms)\r\n\r\n  \r\n  \r\n  \r\n-  preparing 'pckgname':\r\n   checking DESCRIPTION meta-information ...\r\n  \r\n   checking DESCRIPTION meta-information ... \r\n  \r\nv  checking DESCRIPTION meta-information\r\n\r\n  \r\n  \r\n  \r\n-  checking for LF line-endings in source and make files and shell scripts\r\n\r\n  \r\n-  checking for empty or unneeded directories\r\n\r\n  \r\n  \r\n  \r\n-  building 'pckgname_0.0.0.9000.tar.gz'\r\n\r\n  \r\n   \r\n\r\nRunning \"C:/MY_RST~1/R-41~1.3/bin/x64/Rcmd.exe\" INSTALL \\\r\n  \"C:\\Users\\delonp\\AppData\\Local\\Temp\\RtmpglHL13/pckgname_0.0.0.9000.tar.gz\" \\\r\n  --install-tests \r\n* installing to library 'C:/My_RStudio/pckgs'\r\n* installing *source* package 'pckgname' ...\r\n** using staged installation\r\n** R\r\n** byte-compile and prepare package for lazy loading\r\n** help\r\nNo man pages found in package  'pckgname' \r\n*** installing help indices\r\n** building package indices\r\n** testing if installed package can be loaded from temporary location\r\n*** arch - i386\r\n*** arch - x64\r\n** testing if installed package can be loaded from final location\r\n*** arch - i386\r\n*** arch - x64\r\n** testing if installed package keeps a record of temporary installation path\r\n* DONE (pckgname)\r\n\r\nOnce the package is installed, library it in to use its functions (as with any package!).\r\n\r\n\r\nlibrary(pckgname)\r\nadd_3(1)\r\n\r\nError in add_3(1): could not find function \"add_3\"\r\n\r\nAnnoyingly this does not work!\r\nWe will need to add few more steps for it to work, but in the meantime we can use a different function to allow us try out our functions at the development stage.\r\n\r\n\r\ndevtools::load_all(\"pckgname\")\r\nadd_3(1)\r\n\r\n[1] 4\r\n\r\nWorked as a charm! Using load_all is the fastest way to try out the functionality of your new functions, so you’re likely to be using it often while building your package.\r\nOk, but what do you need to do for it to work properly? You’ll have to add proper documentation to your functions.\r\nPackage exercises - building a package\r\nThese were designed for small group/paired coding, but you should ba able to complete these on your own based on the information from above sections.\r\n\r\nExercises\r\n\r\n\r\n# 1. Create your own package ----\r\n# Create your own package and inspect the directory created in win explorer or\r\n# in R \"files\" window on the bottom right. \r\n\r\n\r\n# 2. Add an .R script to the R folder of the package, that will store your \r\n# functions. You can do it manually or using usethis package.\r\n\r\n\r\n# 3. Add a simple function to your package.\r\n\r\n\r\n# 4. Install and library in your package and try calling the function.\r\n\r\n\r\n# 5. Use appropriate devtools:: function (which one?) to load the package and\r\n# try calling your function.\r\n\r\n\r\nSolutions\r\n\r\n\r\n# 1. Create your own package ----\r\n# Create your own package and inspect the directory created in win explorer or\r\n# in R \"files\" window on the bottom right. \r\ndevtools::create(\"my.awesome.package\")\r\n\r\n# 2. Add an .R script to the R folder of the package, that will store your \r\n# functions. You can do it manually or using usethis package.\r\nsetwd(\"my.awesome.package\") \r\nusethis::use_r(\"my_functions\") \r\n\r\n# 3. Add a simple function to your package. \r\nadd_3 <- function(x) {\r\n  x + 3\r\n}\r\n\r\n# You can simply copy/paste the above into my_functions script OR run:\r\ndump(\"add_3\", file = \"my.awesome.package/R/my_functions.R\")\r\n\r\n# 4. Install and library in your package and try calling the function.\r\n# make sure to remove add_3 from global environment if you can see it there (Environment tab in R Studio)\r\ndevtools::install(\"my.awesome.package\")\r\nlibrary(my.awesome.package)\r\n\r\nadd_3(1)\r\n# this should give you an error!\r\n\r\n# 5. Use appropriate devtools:: function (which one?) to load the package and\r\n# try calling your function.\r\ndevtools::load_all(\"my.awesome.package\")\r\n\r\nadd_3(1)\r\n# this should work!\r\n\r\n\r\n\r\nPackage documentation\r\nIndividual functions in a package need their own documentation. You should also include some documentation for functions even for smaller projects, but for packages they need to follow a specific format. For R packages roxygen allows us to build clean documentation. For functions these “comments” are called docstrings.\r\nThe roxygen headers are included in the same script as the function code. You use roxygen comments #’ to identify a line as part of the roxygen header.\r\nMinimum functionality and installing your package\r\nAs a bare minimum your functions need an @export tag to work. Try adding the following line above your function in the “test_functions.R” script:\r\n\r\n\r\n#' @export\r\n\r\n\r\nFor the package to work you need to create documentation with devtools::document() and then install your package using devtools::install. Note that without the export tag devtools::document() the package would not export any functions, so you still wouldn’t be able to use them.\r\n\r\n\r\ndevtools::document(\"pckgname\")\r\n\r\n\r\nYou should see the message “Writing NAMESPACE”. Open the NAMESPACE file and see what changed.\r\nFirst line has not changed, but now there is a new line telling the package to export add_3 function. All the functions you want users to get from your package need to be exported and appear in the NAMESPACE.\r\nNow, when you install your package you can library it in and use it’s functions.\r\nFunctions’ docstrings\r\nThe first three lines of the header have special meaning and you don’t need to use tags to identify them. The first three lines are title, description and details. Since you don’t use any tags to identify the first three lines, it is necessary that you separate them by a new line. For example:\r\n\r\n\r\n#' Title of the function\r\n#'\r\n#' Description of what function does\r\n#'\r\n#' Details\r\n\r\n\r\nOne of the most important aspects of a function to document are the arguments. With roxygen you specify them with the @param tag. You follow the tag with the argument name and then any details the user needs to know. If there is a lot of information that you need to provide about an argument you might want to consider putting this in the details section instead.\r\n\r\n\r\n#' @param x Description of the x argument\r\n\r\n\r\nReturn header will the users what to expect as an output of the function.\r\n\r\n\r\n#' @return Description of the output\r\n\r\n\r\nOnly exported functions will be loaded and directly accessible to users when they load a package, so make sure to add the export tags.\r\n\r\n\r\n#' @export\r\n\r\n\r\nExample roxygen docstrings\r\nThis is minimal documentation that each function should have:\r\n* title\r\n* description\r\n* params\r\n* return\r\n* export tag (if exported)\r\n\r\n\r\n#' Add three\r\n#' \r\n#' Computes sum of given number and 3\r\n#' \r\n#' @param x Numeric vector\r\n#' \r\n#' @return Numeric vector with values increased by 3\r\n\r\n\r\nAnother tag that you’ll likely use often is @import tag, which will attach other packages that your functions use and make sure they are installed when your package is installed.\r\n\r\n\r\n#' @import purrr\r\n#' @import dplyr\r\n\r\n\r\nOptional roxygen tags (advanced content)\r\nYou can also include examples in roxygen header\r\n\r\n\r\n#' @example\r\n#' \\dontrun{\r\n#'   mean(5)\r\n#'}\r\n\r\n\r\nWhen you write documentation you may want to format the text to look like code, link to other functions or, particularly for return objects, format as a bulleted list. You can do this using special formatting:\r\nFor code you use:\r\nTo link to other functions you use:\r\nNote the package name is only required if the function is not in your package.\r\nTo include an unordered list you use:\r\nInside the brackets you mark new items with\r\nfollowed by the item text.\r\n\r\n\r\n#' @return This function returns a \\code{data.frame} including columns:\r\n#' \\itemize{\r\n#'  \\item colname\r\n#'  \\item colname2\r\n#' }\r\n\r\n\r\nadd author\r\n\r\n\r\n#' @author My Name <myemail@example.com>\r\n\r\n\r\nif you want to link to other functions\r\n\r\n\r\n#' @seealso \\code{\\link[packagename]{functioname}}\r\n\r\n\r\nIn addition to the individual functions you can also document the whole package.\r\nWhen you document a package you can use all of the same tags as for functions but the problem that you have is that there is no R code to document. Instead you put the keyword “_PACKAGE” underneath your package header.\r\nThe script should be saved in R directory in file with package name, e.g. pckgname.R\r\n\r\n\r\n#' Title\r\n#'\r\n#' Description\r\n#'\r\n#' @docType package\r\n#' @name pckgname\r\n\"_PACKAGE\"\r\n\r\n[1] \"_PACKAGE\"\r\n\r\nProduce documentation\r\nOnce you created roxygen headers you can create documentation for your package.\r\n\r\n\r\n# Generate package documentation\r\ndevtools::document(\"pckgname\")\r\n\r\n# Examine the contents of the man directory\r\ndir(\"pckgname/man\")\r\n\r\n# View the documentation for the package and it's function\r\nhelp(\"pckgname\")\r\n\r\n# Update the package loaded in your workspace\r\ndevtools::load_all(\"pckgnmme\")\r\n\r\n\r\nUsing roxygen comments will help you build code documentation when you run\r\ndevtools::document function and will update NAMESPACE file, but not the\r\nDESCRIPTION file. You can update the description file manually. For instance, roxygen won’t update the Dependencies or Imports in the DESCRIPTION file.\r\nDocumentation exercises\r\n\r\nExercises\r\n\r\n\r\n# 6. Add roxygen comments to your .R script, above the function definition. \r\n# Then document and update the package loaded into your environment with load_all.\r\n\r\ndevtools::document(\"\")\r\ndevtools::load_all(\"\")\r\n# Now see what happens if you try finding help on your function.\r\n\r\n?your_function_name\r\n\r\n# 7. Add one of the functions from the previous session to your package and \r\n# create roxygen documentation for it.\r\n\r\n\r\nExample solutions\r\n\r\n\r\n# 6. Add roxygen comments to your .R script, above the function definition. \r\n# Then document and update the package loaded into your environment with load_all.\r\n\r\n#' Add three\r\n#'\r\n#' @param x numeric vector\r\n#'\r\n#' @return numeric vetor with values increased by 3\r\n#' @export\r\n\r\nadd_3 <- function(x) {\r\n  x + 3\r\n}\r\n\r\ndevtools::document(\"my.awesome.package\")\r\ndevtools::load_all(\"my.awesome.package\")\r\n# Now see what happens if you try finding help on your function.\r\n\r\n?add_3\r\n\r\n# 7. Add one of the functions from the previous session to your package and \r\n# create roxygen documentation for it.\r\n\r\n\r\n\r\nUnit testing and Quality Assurance\r\nWhat are unit tests?\r\nUnit tests check whether functions do what is expected of them. No more no less. Ideally, you would like a 100% of test coverage, which means that every functions has tests that check for every eventuality. More realistically 60-70% test coverage is very good.\r\nTo create unit tests, you’ll produce dummy data and run your function using this data to check if it produces expected output. Not as difficult as it sounds is it?\r\nWhere to put unit tests in a package?\r\nSetting up folder for unit tests\r\n\r\n\r\nusethis::use_testthat() # your wd should be in the package\r\n\r\n\r\nYou could also create these folders manually - let’s have a look how it should look like.\r\n\r\n\r\ndir(\"pckgname\")\r\n\r\n[1] \"DESCRIPTION\" \"NAMESPACE\"   \"R\"          \r\n\r\nYou can see a folder called tests - let’s see what’s inside.\r\n\r\n\r\ndir(\"pckgname/tests\")\r\n\r\ncharacter(0)\r\n\r\nHow to write unit tests with testthat?\r\nFor each function you’ll need a separate .R file named test-function_name.R. Inside you create test data and output that function should produce for the test data you create within the test script. Then you compare the expected output (that is hardcoded) with output of the function.\r\nYou can create testing scripts manually - just as describe above or for function called “function_name” you can use:\r\n\r\n\r\nusethis::use_test(\"function_name\") # creates and opens tests/testthat/test-function_name.R\r\n\r\n\r\nIf your functions are grouped in an R script together e.g. pckgname/R/data_processing.R your test files should be named the same as the function files, e.g.:\r\n\r\n\r\nusethis::use_test(\"data_processing\") # creates and opens tests/testthat/test-data_processing.R\r\n\r\n\r\nYou can use expect_equal(), expect_equivalent() and expect_identical() in order to test whether the output of a function is as expected. These three functions all have slightly different functionality:\r\ntestthat::expect_identical() checks that the values, attributes, and type of both objects are the same.\r\ntestthat::expect_equal() checks that the values, and attributes of both objects are the same. You can adjust how testthat::strict expect_equal() is by adjusting the tolerance parameter.\r\ntestthat::expect_equivalent() checks that the values, of both objects are the same.\r\nSee example of what test script should contain:\r\n\r\n\r\ntest_data <- c(2, 3)\r\nexpected_output <- c(5, 6)\r\nfunction_output <- add_3(test_data)\r\n\r\n\r\ntestthat::test_that(\"Checking expected outcome matches outcome for add_3 function\", {\r\n  testthat::expect_identical(function_output, expected_output)\r\n})\r\n\r\n\r\nWhat should you be testing?\r\nEverything that is crucial for the function to work. It is not possible to test for every possibility, but checking how function will handle various combination of arguments, extra columns or different types of values (e.g. 0, NaNs, empty cells) can be useful. You can also check if function will throw an error or a warning when it shoud:\r\n\r\n\r\ntestthat::expect_error(1 / \"a\")\r\n\r\ntestthat::expect_warning(log(-1))\r\n\r\n\r\nOther tests can involve testing whether output is of specific size or class. Functions that will check for these aspects are:\r\n\r\n\r\ntestthat::expect_length()\r\ntestthat::expect_s3_class()\r\ntestthat::expect_s4_class()\r\ntestthat::expect_type()\r\n\r\n\r\nHow many tests for a function? (optional)\r\nEach function needs to have a single file for unit tests, but there can be multiple unit tests inside. For instance, if your function includes conditional statements, you should tests all of the conditions (e.g. TRUE/FALSE).\r\n\r\n\r\nset_y_if_x <- function(y, x = TRUE){\r\n  if (x == TRUE) {\r\n    y <- y + 1\r\n  }\r\n  y\r\n}\r\n\r\n\r\ntestthat::test_that(\"Checking expected outcome when x is TRUE\", {\r\n  test_y <- 1\r\n  expected_output <- 2\r\n  function_output <- set_y_if_x(test_y, x = TRUE)\r\n  testthat::expect_identical(function_output, expected_output)\r\n})\r\n\r\nTest passed \r\n\r\ntestthat::test_that(\"Checking expected outcome when x is FALSE\", {\r\n  test_y <- 1\r\n  expected_output <- 1\r\n  function_output <- set_y_if_x(test_y, x = FALSE)\r\n  testthat::expect_identical(function_output, expected_output)\r\n})\r\n\r\nTest passed \r\n\r\nYou can also have multiple “expect” functions inside one “test_that” statement. This could be useful when checking multiple properties of the output. For instance:\r\n\r\n\r\nchange_col_to_factor <- function(df, col_name) {\r\n  df[, col_name] <- as.factor(df[, col_name])\r\n  df\r\n}\r\n\r\ntestthat::test_that(\"Checking data frame column types are as expected\", {\r\n  test_df <- data.frame(\r\n    a = 1:3, \r\n    b = c(\"a\", \"b\", \"c\"), \r\n    c = c(\"A\", \"A\", \"B\")\r\n  )\r\n  function_output <- change_col_to_factor(test_df, col_name = \"c\")\r\n  \r\n  testthat::expect_type(function_output[, \"a\"], \"integer\")\r\n  testthat::expect_type(function_output[, \"b\"], \"character\")\r\n  testthat::expect_s3_class(function_output[, \"c\"], \"factor\")\r\n})\r\n\r\nTest passed \r\n\r\nTesting your package\r\nIt is good to run unit tests on the package whenever you change functionality. There is a simple way to do it:\r\n\r\n\r\ndevtools::test(\"pckgname\")\r\n\r\n\r\nUnExported functions (optional)\r\nTesting non exported functions:\r\n\r\n\r\ntestthat::expect_equal(pkgname:::function_name(input), expected_output)\r\n\r\n\r\nOnly exported functions will be loaded and directly accessible to users when they load a package.\r\nHowever it is possible to access non exported functions of a package:\r\n\r\n\r\npckgname:::nonExpfun(arg1)\r\n\r\n\r\nQuality Assurance\r\nComplex pipelines should contain unit tests that cover most functions. However, you still should have your code peer reviewed and quality assured by another analyst.\r\nTesting excercises\r\n\r\nExercises\r\n\r\n\r\n# 8. Create unit tests for both functions in your package.\r\n\r\n\r\n# 9. Run unit tests for the package.\r\n\r\n\r\nExample solutions\r\n\r\n\r\n# 8. Create unit tests for both functions in your package.\r\nusethis::use_testthat() # create folder for tests in your package\r\nusethis::use_test(\"add_3\") # this can be also created manually\r\n\r\n# copy the below into my.awesome.package/tests/testthat/test-add_3.R\r\ntestthat::testthat(\"Function adds 3 to a vector\", {\r\n  output <- add_3(1)\r\n  expected_output <- 4\r\n  testthat::expect_equal(output, expected_output)\r\n})\r\n\r\n\r\n# 9. Run unit tests for the package.\r\ndevtools::test(\"my.awesome.package\")\r\n\r\n\r\n\r\nHow to share your package?\r\nUpload the package folder on git, then people can simmply clone it and run devtools::install() !\r\nYou can also add on cran, but we won’t cover that here - see more advanced resources below.\r\nAdditional resources\r\nFor more information see:\r\nPackaging your code in R - book\r\nPackages in R and Python - course on LearningHub\r\nIntroduction to Unit Testing - course on LearningHub\r\nNote that LearningHub resources are only available for colleagues from ONS and other government departments.\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-25T14:34:49+01:00"
    },
    {
      "path": "panel_template.html",
      "title": "Panels template",
      "author": [],
      "contents": "\r\n\r\nContents\r\nTesting excercises\r\n\r\nTesting excercises\r\n\r\nExercises\r\n\r\n\r\n\r\nExample solutions\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-25T13:44:45+01:00"
    },
    {
      "path": "projects.html",
      "title": "Structure for analytical projects",
      "author": [],
      "contents": "\r\n\r\nContents\r\nCode structure\r\nSmall project\r\nStructure\r\nQuality assurance of code\r\nQuiz 1\r\n\r\nMedium project\r\nStructure\r\nQuality assurance\r\n\r\nLarge project\r\nStructure\r\nQuality assurance\r\n\r\n\r\nCode structure\r\nThere is no one good solution to structuring your RAP projects. There is a lot of flexibility in how you do it and it will depend on the type of work you do. Nevertheless, especially when you start with RAP it can be really helpful to have a template to use. What is the best practice for structuring a project is one of the most common questions when we start working on RAP with a new team. The examples below are one good way to do this, but not the only way. Some of advice here is universal though - you should always have a README file and it should be clear which script you need to run.\r\nOptimal code structure will depend on volume and complexity of analysis. We’ll cover small, medium and big projects.\r\nSmall project\r\nStructure\r\nFor a small project it might be sufficient to have a single script that does all the work. In this case, the code should be structured as follows:\r\n\r\n\r\n# Config ----\r\n# specify all the variables that require user input at the top. All variables that might change from\r\n# run to run should be here: e.g. locations where to load data from, where to save the outputs, analytical parameters etc.\r\n\r\n# Load packages ----\r\n# library in all the required packages\r\n\r\n# Body of the script ----\r\n# Whatever the code actually does - you can have multiple sections here to make it easy to read.\r\n\r\n\r\nEven for small projects, contained within one script we should have a README file that contains the necessary documentation/instructions. README should ensure that another person can easily run the project.\r\nQuality assurance of code\r\nFor a small project any tests should be implemented in the body of the script - this can be simple sanity checks i.e. if statements printing a message or can use testthat “expect” functions. Some sanity checks might be useful, but for small projects most important part of QA will be for another analyst to quality assurance your code to check if it works as expected.\r\nQuiz 1\r\n\r\nQuestion\r\nWhat do you class as a small project?\r\n\r\nProject with less than 10 bespoke functions\r\n\r\n\r\nProject that comfortable fits in a single script\r\n\r\n\r\nProject producing less than 10 tables\r\n\r\n\r\nProject that uses no more than 3 scripts for analysis\r\n\r\nSee Answer\r\nWhat do you class as a small project?\r\n\r\nProject with less than 10 bespoke functions\r\n\r\n\r\nProject that comfortable fits in a single script\r\n\r\n\r\nProject producing less than 10 tables\r\n\r\n\r\nProject that uses no more than 3 scripts for analysis\r\n\r\nOur guidance for small projects is aproppriate for projects that would fit in a single script.\r\n\r\nMedium project\r\nStructure\r\nIn a medium size project you will likely need to have multiple scripts. First, you’ll need a README file that will explain to any future users how to run the code, which parameters need to be updated and where. If there is no other documentation this is also the place to specify any dependencies, versions, authors etc. README should generally be in .txt format.\r\nYou should have a separate config file with all the variables that require user input. Config file can be e.g. in yaml or R script format. This way you are less likely to introduce errors into the analytical part of the project and it is easy to modify parameters.\r\nFor medium size projects, you should make your code modular and avoid repetition. This means employing functions to do the heavy lifting for you. Therefore, you’ll need another R script where all the functions are stored.\r\nFinally, you’ll have a “main” script (it doesn’t have to be called main, but it should be clear which one to run), that does all the work. To take advantage of the config and functions you created you can simply use the source() function to call these into your environment.\r\nproject/\r\n  README.txt\r\n  config.yaml OR config.R\r\n  functions.R\r\n  main.R\r\nQuality assurance\r\nFor a medium project you should consider creating unit tests for your functions. This can be done in a simple fashion e.g. by creating another R script that will source all the functions and run tests for them. You should still have another analyst QA your code.\r\nLarge project\r\nStructure\r\nUsually, best way to structure large or complex projects is going to be putting it in a package (see the packages page). Alternatively you could adopt a structure similar to a package, that will help you manage the abundance of code and tests you’ll need to produce.\r\nproject/\r\n\r\n  functions/\r\n    analytical_functions.R\r\n    data_processing_functions.R\r\n    super_complex_modelling_functions.R\r\n    \r\n  tests/\r\n    test_function_F.R\r\n    ...\r\n  \r\n  README.txt\r\n  config.yaml OR config.R\r\n  main.R\r\nQuality assurance\r\nFor a big project, you should really unit test your functions. As always code should be quality assured by another analyst. Ideally you should produce logs each time your code is run with outcomes of your sanity checks and any parameters specified in the config.\r\nQ3,4\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-25T13:49:15+01:00"
    }
  ],
  "collections": []
}
