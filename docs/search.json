{
  "articles": [
    {
      "path": "about.html",
      "title": "About this site",
      "author": [],
      "contents": "\r\nWho is RAPID and why we have created this page.\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-25T18:26:30+01:00"
    },
    {
      "path": "advanced_functions.html",
      "title": " Advanced Functions in R",
      "author": [],
      "contents": "\r\n\r\nContents\r\nFunctionals\r\nAnonymous functions\r\nLists of functions\r\nFunctions with Dynamic Arguments\r\nData Masking\r\nTidy Selection\r\nQuiz\r\nDynamic data selection excercises\r\n\r\n\r\nPrerequisites:\r\nKnowledge of dplyr package\r\nFunctionals\r\nThe apply family of functions (lapply(), sapply(), vapply()) can be used within bespoke functions or used to apply bespoke functions, not just regular functions.\r\n\r\n\r\nvector <- c(1, NA, 3, 4, 5)\r\ndataframe <- data.frame(col1 = c(NA, NA, 6, 8),\r\n                        col2 = c(2, 4, NA, 9))\r\n\r\ndata_list <- list(vector, dataframe)\r\n\r\n## lapply for a bespoke function\r\n\r\ncut_in_half <- function(data) {\r\n  data / 2\r\n}\r\n\r\ncut_in_half(vector)\r\n\r\n[1] 0.5  NA 1.5 2.0 2.5\r\n\r\ncut_in_half(dataframe)\r\n\r\n  col1 col2\r\n1   NA  1.0\r\n2   NA  2.0\r\n3    3   NA\r\n4    4  4.5\r\n\r\nlapply(data_list, cut_in_half)\r\n\r\n[[1]]\r\n[1] 0.5  NA 1.5 2.0 2.5\r\n\r\n[[2]]\r\n  col1 col2\r\n1   NA  1.0\r\n2   NA  2.0\r\n3    3   NA\r\n4    4  4.5\r\n\r\n\r\n\r\n## lapply inside function\r\n\r\ncut_list_in_half <- function(list) {\r\n  lapply(list, cut_in_half)\r\n}\r\n\r\ncut_list_in_half(data_list)\r\n\r\n[[1]]\r\n[1] 0.5  NA 1.5 2.0 2.5\r\n\r\n[[2]]\r\n  col1 col2\r\n1   NA  1.0\r\n2   NA  2.0\r\n3    3   NA\r\n4    4  4.5\r\n\r\nAnonymous functions\r\nNot all functions need to be named. Small (one-line) functions that are not worth naming are called anonymous functions.\r\nA good rule of thumb is that an anonymous function should fit on one line and shouldn’t need to use {}.\r\n\r\n\r\nsapply(starwars, function(x) length(unique(x)))\r\n\r\n      name     height       mass hair_color skin_color  eye_color \r\n        87         46         39         13         31         15 \r\nbirth_year        sex     gender  homeworld    species      films \r\n        37          5          3         49         38         24 \r\n  vehicles  starships \r\n        11         17 \r\n\r\n# Keeps only non-numeric columns\r\nhead(Filter(function(x) !is.numeric(x), starwars))\r\n\r\n# A tibble: 6 x 11\r\n  name      hair_~1 skin_~2 eye_c~3 sex   gender homew~4 species films\r\n  <chr>     <chr>   <chr>   <chr>   <chr> <chr>  <chr>   <chr>   <lis>\r\n1 Luke Sky~ blond   fair    blue    male  mascu~ Tatooi~ Human   <chr>\r\n2 C-3PO     <NA>    gold    yellow  none  mascu~ Tatooi~ Droid   <chr>\r\n3 R2-D2     <NA>    white,~ red     none  mascu~ Naboo   Droid   <chr>\r\n4 Darth Va~ none    white   yellow  male  mascu~ Tatooi~ Human   <chr>\r\n5 Leia Org~ brown   light   brown   fema~ femin~ Aldera~ Human   <chr>\r\n6 Owen Lars brown,~ light   blue    male  mascu~ Tatooi~ Human   <chr>\r\n# ... with 2 more variables: vehicles <list>, starships <list>, and\r\n#   abbreviated variable names 1: hair_color, 2: skin_color,\r\n#   3: eye_color, 4: homeworld\r\n# i Use `colnames()` to see all variable names\r\n\r\n# Integrates x to the power of 2 using limits of 0 and 10\r\nintegrate(function(x) x ^ 2, 0, 10)\r\n\r\n333.3333 with absolute error < 3.7e-12\r\n\r\nLists of functions\r\nThe best way to group functions together is using packages.\r\nIf you are not going to build a package for your functions, a simple way to group similar/related functions together is to combine them into a list (remember, functions are objects).\r\nYou then call them the same way that you would call a list element.\r\nThis is not generally recommended.\r\n\r\n\r\nfunction_list <- list(\r\n  half_num = function(x) x / 2,\r\n  double_num = function(x) x * 2\r\n)\r\n\r\nfunction_list$double_num(10)\r\n\r\n[1] 20\r\n\r\nFunctions with Dynamic Arguments\r\nUsing base r and dplyr Function Tidy Evaluation\r\nSome variables, commonly column names, can be dependent on some external factor (e.g. user input, data values) and you may want to manipulate them in a generic way in using function arguments. This can commonly happen when you want to choose the column of interest manually in a function or when iterating/looping through.\r\nThis can be done with base r, using variable selection such as square brackets [] and double square brackets [[]].\r\nFor example, using base r:\r\n\r\n\r\ncolour_data <- data.frame(red = c(1, 2, 3),\r\n                          blue = c(5, 7, 3),\r\n                          green = c(9, 8, 7))\r\n\r\n# I want to get the mean of one column of my choice.\r\n\r\ncol_mean <- function(data, col) {\r\n  print(paste0(col, \": \", mean(data[[col]])))\r\n}\r\n\r\ncol_mean(colour_data, \"blue\")\r\n\r\n[1] \"blue: 5\"\r\n\r\n# I want to iterate through the columns using a vector\r\n\r\ncol_vector <- c(\"green\", \"blue\", \"red\")\r\n\r\nfor (colour in col_vector) {\r\n  col_mean(colour_data, colour)\r\n}\r\n\r\n[1] \"green: 8\"\r\n[1] \"blue: 5\"\r\n[1] \"red: 2\"\r\n\r\nSome people prefer to structure their code following tidyverse styling.dplyr provides a way to dynamically manipulate columns, but it makes writing functions containing dplyr functions a bit more complicated.\r\nEnvironmental variables vs data variables\r\nTo determine the syntax to use, you need to remember the distinction between data and environmental variables and which dplyr function uses which.\r\nEnv-variables are “programming” variables that live in an environment, usually created with <-, can be seen in the RStudio Environment window.\r\nData-variables are “statistical” variables that live in a data frame (generally columns).\r\nUse ?dplyr::function() to see which type of formatting the variable uses: data masking or tidy selection.\r\nQuoted vs unquoted variables\r\nThe syntax for dynamic arguments in dplyr are dependent on if the variable (column name) is quoted (a string) or unquoted (not a string).\r\nIt is possible to convert between the two but that gets even more complicated.\r\n\r\n\r\ndf <- data.frame(column_one = c(seq(1, 5, 1)),\r\n                 column_two = c(seq(6, 10, 1)))\r\ncolname <- \"column_one\"\r\n\r\n## Base using the known column name unquoted and quoted\r\ndf$column_one\r\n\r\n[1] 1 2 3 4 5\r\n\r\ndf$\"column_one\"\r\n\r\n[1] 1 2 3 4 5\r\n\r\ndf[, \"column_one\"]\r\n\r\n[1] 1 2 3 4 5\r\n\r\n## Base with a variable column name\r\ndf[[colname]]\r\n\r\n[1] 1 2 3 4 5\r\n\r\ndf[, colname]\r\n\r\n[1] 1 2 3 4 5\r\n\r\n# Doesn't work\r\ndf$colname\r\n\r\nNULL\r\n\r\ndf$\"colname\"\r\n\r\nNULL\r\n\r\ndf[[\"colname\"]]\r\n\r\nNULL\r\n\r\n## dplyr can use unquoted and quoted column names\r\ndplyr::pull(df, column_one)\r\n\r\n[1] 1 2 3 4 5\r\n\r\ndplyr::pull(df, colname)\r\n\r\n[1] 1 2 3 4 5\r\n\r\n## But when you use dplyr functions inside bespoke functions\r\n  # It works like normal if you statically define the column name\r\npull_col_one <- function(data) {\r\n  dplyr::pull(data, column_one)\r\n}\r\npull_col_one(df)\r\n\r\n[1] 1 2 3 4 5\r\n\r\npull_col_one <- function(data) {\r\n  dplyr::pull(data, \"column_one\")\r\n}\r\npull_col_one(df)\r\n\r\n[1] 1 2 3 4 5\r\n\r\n# It becomes more complicated when you want to chose the column with an argument\r\n  # This doesn't work\r\npull_colname <- function(data, column_name) {\r\n  dplyr::pull(data, column_name)\r\n}\r\npull_colname(df, column_one)\r\n\r\nError in `dplyr::pull()`:\r\nCaused by error:\r\n! object 'column_one' not found\r\n\r\nUnquoted\r\nThe variable is generally unquoted when you know what the column name is (i.e. you aren’t pulling it from somewhere else or creating it somehow). This requires external knowledge of the data.\r\nThis is how we use dplyr functions to access column names.\r\nQuoted\r\nQuoted/string variables are generally useful for when the column name is derived from something else in an automated way (e.g. using paste(), colnames() e.t.c.). Column names as strings are much easier to work with than unquoted, but the syntax for creating dynamic arguments is a bit more complicated. These string column names are more flexible as they can be manipulated with normal string manipulation.\r\nArguments\r\nWhen creating dplyr tidy evaluation functions, the first argument should be data.\r\nThen when you are piping with your custom functions, you do not need to give the data argument.\r\nFurther information can be found in dplyr documentation.\r\nData Masking\r\nApplies to:\r\nfilter()\r\ngroup_by()\r\nmutate()\r\nsummarise()\r\narrange()\r\ncount()\r\nCan use column names (i.e. data variables) as if they were variables in the environment, similar to how dplyr variables are called.\r\ni.e. you write column_name, not df$column_name or df[[column_name]]\r\nIf the variable is unquoted/not a string:\r\nNeed to double-embrace it with curly brackets {{variable}} where it is used in the body of the function.\r\nAlso, can use glue syntax with := to name the resulting variables after the unquoted argument variable contained in double curly brackets {{}}.\r\n\r\n\r\ngroup_count_min_max <- function(df, group_var, summ_var) {\r\n  df %>%\r\n    dplyr::group_by({{group_var}}) %>%\r\n    dplyr::summarise(\"n_{{summ_var}}\" := n(),\r\n                     \"min_{{summ_var}}\" := min({{summ_var}}),\r\n                     \"max_{{summ_var}}\" := max({{summ_var}}))\r\n}\r\n\r\ngroup_count_min_max(df = mtcars, group_var = cyl, summ_var = mpg)\r\n\r\n# A tibble: 3 x 4\r\n    cyl n_mpg min_mpg max_mpg\r\n  <dbl> <int>   <dbl>   <dbl>\r\n1     4    11    21.4    33.9\r\n2     6     7    17.8    21.4\r\n3     8    14    10.4    19.2\r\n\r\n# If piping, so long as your first argument of your custom function is the data,\r\n  # you don't need to specify the data using a full-stop\r\n# Can pipe the custom function along with other dplyr functions\r\nmtcars %>%\r\n  dplyr::select(-gear) %>%\r\n  group_count_min_max(group_var = cyl, summ_var = mpg)\r\n\r\n# A tibble: 3 x 4\r\n    cyl n_mpg min_mpg max_mpg\r\n  <dbl> <int>   <dbl>   <dbl>\r\n1     4    11    21.4    33.9\r\n2     6     7    17.8    21.4\r\n3     8    14    10.4    19.2\r\n\r\n## This is much more complicated to do in base\r\n\r\n\r\nIf the variable is quoted/a string:\r\nIf a variable exists as a character string (i.e. as an env-variable), need to indirectly select it from .data in the body of the function where it is used using [[]].\r\nThe .data bit does not vary with different argument names, it is always the .data as it refers to the data within the pipe level above.\r\nCan also use glue syntax with := to name the resulting variables after the quoted argument variable (embraced by single curly brackets {}).\r\n\r\n\r\ngroup_count_min_max <- function(df, group_var, summ_var) {\r\n  df %>%\r\n    dplyr::group_by(.data[[group_var]]) %>%\r\n    dplyr::summarise(\"n_{summ_var}\" := n(),\r\n                     \"min_{summ_var}\" := min(.data[[summ_var]]),\r\n                     \"max_{summ_var}\" := max(.data[[summ_var]]))\r\n}\r\n\r\nmtcars %>%\r\n  group_count_min_max(group_var = \"cyl\", summ_var = \"mpg\")\r\n\r\n# A tibble: 3 x 4\r\n    cyl n_mpg min_mpg max_mpg\r\n  <dbl> <int>   <dbl>   <dbl>\r\n1     4    11    21.4    33.9\r\n2     6     7    17.8    21.4\r\n3     8    14    10.4    19.2\r\n\r\nTidy Selection\r\nApplies to:\r\nselect()\r\nacross()\r\nrename()\r\nrelocate()\r\npull()\r\nCan easily choose variables based on their position, name or type.\r\ne.g. starts_with(\"x\") or is.numeric()\r\nIf the variable is unquoted:\r\nSimilar to data masking, you can use embracing with double curly brackets {{}}.\r\n\r\n\r\ndrop_rename_iris <- function(data, drop_var, chosen_var) {\r\n  data %>%\r\n    dplyr::select(-{{drop_var}}) %>%\r\n    dplyr::rename(var_of_interest = {{chosen_var}})\r\n}\r\n\r\niris %>%\r\n  drop_rename_iris(drop_var = Sepal.Length,\r\n                   chosen_var = Species) %>%\r\n  head()\r\n\r\n  Sepal.Width Petal.Length Petal.Width var_of_interest\r\n1         3.5          1.4         0.2          setosa\r\n2         3.0          1.4         0.2          setosa\r\n3         3.2          1.3         0.2          setosa\r\n4         3.1          1.5         0.2          setosa\r\n5         3.6          1.4         0.2          setosa\r\n6         3.9          1.7         0.4          setosa\r\n\r\nIf the variable is quoted:\r\nSimilar to data masking, can use indirect selection from .data using [[]].\r\n\r\n\r\ndrop_rename_iris <- function(data, drop_var, chosen_var) {\r\n  data %>%\r\n    dplyr::select(-.data[[drop_var]]) %>%\r\n    dplyr::rename(var_of_interest = .data[[chosen_var]])\r\n}\r\n\r\niris %>%\r\n  drop_rename_iris(drop_var = \"Sepal.Length\",\r\n                   chosen_var = \"Species\") %>%\r\n  head()\r\n\r\n  Sepal.Width Petal.Length Petal.Width var_of_interest\r\n1         3.5          1.4         0.2          setosa\r\n2         3.0          1.4         0.2          setosa\r\n3         3.2          1.3         0.2          setosa\r\n4         3.1          1.5         0.2          setosa\r\n5         3.6          1.4         0.2          setosa\r\n6         3.9          1.7         0.4          setosa\r\n\r\n# As seen in the warning above, it appears that .data[[var]] \r\n  # has now been depreciated\r\n\r\ndrop_rename_iris <- function(data, drop_var, chosen_var) {\r\n  data %>%\r\n    dplyr::select(-all_of(drop_var)) %>%\r\n    dplyr::rename(var_of_interest = .data[[chosen_var]])\r\n}\r\n\r\niris %>%\r\n  drop_rename_iris(drop_var = \"Sepal.Length\",\r\n                   chosen_var = \"Species\") %>%\r\n  head()\r\n\r\n  Sepal.Width Petal.Length Petal.Width var_of_interest\r\n1         3.5          1.4         0.2          setosa\r\n2         3.0          1.4         0.2          setosa\r\n3         3.2          1.3         0.2          setosa\r\n4         3.1          1.5         0.2          setosa\r\n5         3.6          1.4         0.2          setosa\r\n6         3.9          1.7         0.4          setosa\r\n\r\n## More advanced example\r\n\r\ndf <- data.frame(index_partial = sample(0:1, size = 100, replace = TRUE),\r\n                 index_all = sample(0:1, size = 100, replace = TRUE),\r\n                 days_partial = sample(x = 0:100, size = 100),\r\n                 days_all = sample(x = 0:100, size = 100))\r\n\r\nmean_day <- function(var_name) {\r\n  df %>%\r\n    dplyr::filter(.data[[paste0(\"index_\", var_name)]] == 1) %>%\r\n    dplyr::summarise(\"mean_days_{ var_name }\" := \r\n                       mean(.data[[paste0(\"days_\", var_name)]], na.rm = TRUE))\r\n}\r\n\r\nmean_day(\"partial\")\r\n\r\n  mean_days_partial\r\n1             52.24\r\n\r\nQuiz\r\n\r\nQuestion\r\nHow do you select a variable in a function with data masking?\r\n\r\nunquoted: {var} quoted: [var]\r\n\r\n\r\nquoted: {var} unquoted: [var]\r\n\r\n\r\nunquoted: {{var}} quoted: .data[[var]]\r\n\r\n\r\nquoted: {{var}} unquoted: .data[[var]]\r\n\r\nSee Answer\r\nHow do you select a variable in a function with data masking?\r\n\r\nunquoted: {var} quoted: [var]\r\n\r\n\r\nquoted: {var} unquoted: [var]\r\n\r\n\r\nunquoted: {{var}} quoted: .data[[var]]\r\n\r\n\r\nquoted: {{var}} unquoted: .data[[var]]\r\n\r\n\r\nDynamic data selection excercises\r\n\r\nExercises\r\n\r\n\r\n##### Exercise 3 - Dplyr Data Masking vs base -----\r\n\r\n## Write 3 functions to keep rows in a starwars dataset (from dplyr) if it \r\n  ## contains a certain value in a selected column \r\n## 1) using dplyr where the column name is unquoted\r\n## 2) using dplyr where the column name is quoted\r\n## 3) in base r\r\n\r\n# Test if your function works by selecting those who are \"feminine\" in \r\n  # the gender column\r\n\r\ndata(\"starwars\")\r\n\r\n\r\n##### Exercise 4 - Dplyr Tidy Selection vs base -----\r\n\r\n## Write a function to select the winning team (given by an argument)\r\n## Then sort the winning team into alphabetical order\r\n## using both base r and dplyr\r\n## EXTRA: Loop over each of the names and save the output as <team_name>_wins\r\n## using both base r and dplyr\r\n\r\nteam_names <- c(\"apple\", \"banana\", \"orange\", \"pear\")\r\n\r\nschool_teams <- data.frame(\r\n  apple = c(\"Willibald\", \"Kilie\", \"Anuradha\", \"Theodora\"),\r\n  banana = c(\"Branislav\", \"Thorbjorn\", \"Ward\", \"Silvana\"),\r\n  orange = c(\"Seeta\", \"Yota\", \"Griet\", \"Edmund\"),\r\n  pear = c(\"Gyula\", \"Della\", \"Duru\", \"Sutekh\"))\r\n\r\n\r\nExample solutions\r\n\r\n\r\n##### Answer 3 -----\r\n\r\n# dplyr - unquoted column name\r\nstarwars_filter_unquoted <- function(data,\r\n                                     col_name_filter,\r\n                                     filter_by) {\r\n  dplyr::filter(data, {{col_name_filter}} == filter_by)\r\n}\r\n\r\nstarwars_filter_unquoted(data = starwars,\r\n                         col_name_filter = gender,\r\n                         filter_by = \"feminine\")\r\n\r\n# dplyr - quoted column name\r\n\r\nstarwars_filter_quoted <- function(data,\r\n                                   col_name_filter,\r\n                                   filter_by) {\r\n  dplyr::filter(data, .data[[col_name_filter]] == filter_by)\r\n}\r\n\r\nstarwars_filter_quoted(data = starwars,\r\n                       col_name_filter = \"gender\",\r\n                       filter_by = \"feminine\")\r\n\r\n# Base\r\nstarwars_filter_base <- function(data,\r\n                                 col_name_filter,\r\n                                 filter_by) {\r\n  data[which(data[[col_name_filter]] == filter_by), ]\r\n}\r\n\r\nstarwars_filter_base(data = starwars,\r\n                     col_name_filter = \"gender\",\r\n                     filter_by = \"feminine\")\r\n\r\n##### Answer 4 -----\r\n\r\nwinning_team_alph <- function(data, winning_team) {\r\n\r\n  data <- data %>%\r\n    dplyr::select(winning_team)\r\n\r\n  data <- data.frame(data[order(data[1]), ])\r\n  colnames(data) <- \"winning team\"\r\n\r\n  data\r\n\r\n}\r\n\r\nwinning_team_alph(data = school_teams, winning_team = \"apple\")\r\n\r\nwinning_team_alph <- function(data, winning_team) {\r\n  \r\n  data <- data %>%\r\n    dplyr::select({{winning_team}})\r\n  \r\n  data <- data.frame(data[order(data[1]), ])\r\n  colnames(data) <- \"winning team\"\r\n  \r\n  data\r\n  \r\n}\r\n\r\nwinning_team_alph(data = school_teams, winning_team = \"apple\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-25T18:26:43+01:00"
    },
    {
      "path": "control_flow.html",
      "title": "Control Flow and Loops in R",
      "author": [],
      "contents": "\r\n\r\nContents\r\nWhat are loops?\r\nFor loops\r\nQuiz 1\r\nExample of the advantages of a for loop\r\nDo I have to use x?\r\nWill I actually use this much?\r\nMy loop is stuck!\r\n\r\nwhile loops\r\nSyntax\r\nExample of a while loop\r\nWill I actually use this much?\r\nLoop excercises\r\n\r\nif statements (control flow)\r\nQuiz 2\r\nExample: traffic lights\r\nelse\r\nelse if\r\nifelse\r\nQuiz 3\r\nControl flow exercises\r\n\r\nCombining loops/conditional statements\r\nExample\r\nQuiz 4\r\nKeep track of your brackets\r\n\r\nAdvanced loop features\r\nBreak\r\nNext\r\nLooping index\r\nControl flow and loops excercises\r\n\r\nAdditional resources\r\n\r\nPre-requisites:\r\nhave RStudio installed\r\npackages required: tidyverse\r\nbasic R knowledge (e.g., variable assignment)\r\nWhat are loops?\r\nLoops are coding structures that help repeat highly similar or repetitive code effectively, without the need for copy-pasting. They increase code efficiency and readability.\r\nTypes of loops:\r\nfor loop (do something x times)\r\nwhile loop (do something until a certain event is reached)\r\nif statements (control flow, not actually a ‘proper’ loop)\r\nFor loops\r\nWhat is a for loop? It does something repeatedly a certain amount of times.\r\nSyntax\r\nfor (values to loop over) {\r\n  do all of this stuff for the current value\r\n}\r\nThe for loop keeps repeating until the last value is reached.\r\nIn a bit more appropriate coding jargon:\r\nfor (var in seq) {\r\n  expr\r\n}\r\nWhere var = variable, seq = sequence, and expr = expression. You need to use these specific types of brackets in the correct place, otherwise the for loop won’t work.\r\nA really simple example is:\r\n\r\n\r\nfor (x in 1:10) {\r\n  print(x)\r\n}\r\n\r\n\r\nHere, x is defined as 1:10 (a sequence of 1 to 10 in steps of 1, i.e., 1, 2, 3, … 10). The first time the loop runs, x <- 1, so it prints 1. The second time, x <- 2, so it prints 2. Etc. Until x <- 10 has been printed, then it stops as x has no further values.\r\nQuiz 1\r\n\r\nQuestion\r\nWhat is the output of the following for loop:\r\n\r\n\r\nfor (x in 1:2) {\r\n  y <- x + 3\r\n  print(y) \r\n}\r\n\r\n\r\n\r\n1, 2\r\n\r\n\r\n3, 4\r\n\r\n\r\n4, 5\r\n\r\n\r\n5, 6\r\n\r\nSee Answer\r\nWhat is the output of the following for loop:\r\n\r\n\r\nfor (x in 1:2) {\r\n  y <- x + 3\r\n  print(y) \r\n}\r\n\r\n\r\n\r\n1, 2\r\n\r\n\r\n3, 4\r\n\r\n\r\n4, 5\r\n\r\n\r\n5, 6\r\n\r\n\r\nExample of the advantages of a for loop\r\nConsider the following scenario. You want to create 3 variables, each is equal to the previous variable, plus 1.\r\n\r\n\r\na <- 1\r\nb <- a + 1\r\nc <- b + 1\r\nd <- c + 1\r\nprint(c(b, c, d))\r\n\r\n\r\nEasy enough to type out, right? If a is a different number, e.g., 3; b, c and d are still calculated correctly and you don’t need to change any lines other than the first where a value is assigned to a. Done!\r\nHowever, it turns out you now need to do the same thing, but rather than just 3 variables, you need to create 100! That’s a lot of copy-pasting to create e, f, g, …\r\nLet’s try to write a for loop to obtain the above 3 output variables:\r\n\r\n\r\ninput_variable <- 1\r\nnumber_of_outputs <- 3\r\noutput <- c() # empty vector to put outputs into\r\nfor (x in 1:number_of_outputs) {\r\n  output[x] <- x + 1\r\n}\r\nprint(output)\r\n\r\n\r\nNot only did you just do the same thing super fast, you also tidied the output into a single list, so you don’t clutter your workspace with lots of separate variables. If you needed the 3rd output, you can obtain it using:\r\n\r\n\r\noutput[3]\r\n\r\n\r\nHey, but that was more lines of code than the copy-pasting above! Yeah, well, now think about when you needed to do this 100 times, instead of 3. All you need to change is:\r\n\r\n\r\ninput_variable <- 1\r\nnumber_of_outputs <- 100\r\noutput <- c() #empty vector to put outputs into\r\nfor (x in 1:number_of_outputs) {\r\n  output[x] <- x + 1\r\n}\r\nprint(output)\r\n\r\n\r\nNo additional lines! And you can still easily change the input variable.\r\nDo I have to use x?\r\nNo! ‘x’ is just a placeholder variable (a bit of a habit in coding examples, you may also see ‘i’ used often), it can be anything you like. In fact, it is a better idea to give it a sensible name (ideally following coding style best practice!) so you and anybody else reading your code can remember/figure out what this loop is actually doing.\r\nLet’s try a more sensible example:\r\n\r\n\r\nbaby_names <- list(\"Oliver\", \"Leo\", \"Olivia\", \"Frank\")\r\n\r\nfor (baby_name in baby_names) {\r\n  print(baby_name)\r\n}\r\n\r\n\r\nWill I actually use this much?\r\nYes, a lot! It is a fundamental tool in coding. It takes some practice, but saves lots of time and effort in computing.\r\nMy loop is stuck!\r\nYour Console is hanging waiting for input, showing a ‘+’, and not a ‘>’. You have most likely forgotten a bracket somewhere. Press ESC and you can correct your loop and try again.\r\nwhile loops\r\nWhat is a while loop? It keeps on doing something continuously until a certain event is reached.\r\nSyntax\r\nwhile (condition) {\r\n  expr\r\n}\r\nWhere condition is a criterion that needs to be satisfied for the loop to keep on running, and expr = expression (some bit of code). The condition uses a Boolean statement, that is: TRUE of FALSE. As long as the condition equals TRUE, the while loop will keep on executing the expression. As soon as this condition equals FALSE, it stops.\r\nExample of a while loop\r\nYou have 20 apples. You are handing out 1 at a time to others. Once you only have 2 apples left, you want to stop handing them out, so that you have some for yourself.\r\n\r\n\r\nnum_apples <- 20\r\nwhile (num_apples > 2) {\r\n  print(\"Keep handing out apples\")\r\n  num_apples <- num_apples - 1\r\n}\r\nprint(paste0(\"Stop handing out apples, because you only have \", num_apples, \" left\"))\r\n\r\n\r\nWhat happened there? The loop ran initially with num_apples = 20. On the next iteration, num_apples <- 19, and 19 > 2 == TRUE, so it kept on running, then it was 18, 17, etc, until num_apples <- 2 and 2 > 2 == FALSE, so the loop stopped and the print line below the closing bracket of the loop was executed.\r\nFun anecdote - while (!!) I was writing this loop, I made a typo, which meant the loop kept going forever as the condition never changed to FALSE! (Try the following code, then Press ESC to exit the stuck loop):\r\nnum_apples <- 20\r\nwhile (num_apples > 2) {\r\n  print(\"Keep handing out apples\")\r\n  num_applies <- num_apples - 1\r\n}\r\nprint(num_apples)\r\nYou can see that num_apples never changed from 20, so the while condition remained TRUE at all times!\r\nWill I actually use this much?\r\nDepends. In analytical work, probably not as much as for loops. But it has its uses.\r\nLoop excercises\r\n\r\nExercises\r\n\r\n# Exercise 1: Try and write a for loop, printing the numbers 1 to 20:\r\n\r\n\r\n# Exercise 2: This for loop doesn't work. Why not? Try to fix it:\r\n\r\nfor i in 1:10 {\r\n  print(i)\r\n}\r\n\r\n# Exercise 3: Try and write a while loop, increasing a variable 'i' by 1 at each\r\n# iteration, starting with i <- 1. Keep running until i reaches 6, then stop.\r\n# Print i at each iteration to keep track of your loop:\r\n\r\nExample solutions\r\n\r\n\r\n# Exercise 1: Try and write a for loop, printing the numbers 1 to 20:\r\nfor (i in 1:20) {\r\n  print(i)\r\n}\r\n\r\n# Exercise 2: This for loop doesn't work. Why not? Try to fix it:\r\n# Answer: you forgot some brackets!\r\nfor (i in 1:10) {\r\n  print(i)\r\n}\r\n\r\n# Exercise 3: Try and write a while loop, increasing a variable 'i' by 1 at each\r\n# iteration, starting with i <- 1. Keep running until i reaches 6, then stop.\r\n# Print i at each iteration to keep track of your loop:\r\ni <- 1\r\nwhile (i < 6) {\r\n  print(i)\r\n  i <- i + 1\r\n}\r\n\r\n\r\n\r\nif statements (control flow)\r\nWhat is an if statement/control flow? It does what it suggests: conditional statements. If some criterion is TRUE, execute an expression. If it is FALSE, don’t execute the expression. This can be expanded with else if to include an additional alternative statement, and/or else to express what to do if none of the above criteria are satisfied (else always goes last).\r\nSyntax\r\nif (test_expression) {\r\n  statement\r\n}\r\nRelational operators\r\nYou need relational operators to run if statements. These simply compare a statement on the left with a statement on the right. Here is a list:\r\na == b “a is equal to b”\r\na > b “a is greater than b”\r\na >= b “a is greater than or equal to b”\r\na < b “a is smaller than b”\r\na <= b “a is smaller than or equal to b”\r\na != b “a is not equal to b”\r\nTry them out, for example:\r\n\r\n\r\na <- 1\r\nb <- 2\r\na == b\r\nb < a\r\na != b\r\n\r\n\r\nYou can see the output in the console is a boolean/logical value, either TRUE or FALSE.\r\nQuiz 2\r\n\r\nQuestion\r\nWhat is the output of: a < b\r\n\r\n\r\na <- 4\r\nb <- 6\r\na < b\r\n\r\n\r\n\r\n2\r\n\r\n\r\nTRUE\r\n\r\n\r\nNA\r\n\r\n\r\nFALSE\r\n\r\nSee Answer\r\nWhat is the output to: a < b\r\n\r\na <- 4\r\nb <- 6\r\na < b\r\n}\r\n\r\n\r\n2\r\n\r\n\r\nTRUE\r\n\r\n\r\nNA\r\n\r\n\r\nFALSE\r\n\r\n\r\nExample: traffic lights\r\nLet’s try to code how a traffic lights work. We’ll start with green:\r\n\r\n\r\nlight_status <- \"green\"\r\nif (light_status == \"green\") {\r\n  print(\"go\")\r\n}\r\n\r\n\r\nYou will get to “go” only if the light is green and for no other value. (Try some other values for light_status)\r\nelse\r\n\r\n\r\nlight_status <- \"green\"\r\nif (light_status == \"green\") {\r\n  print(\"go\")\r\n} else {\r\n  print(\"stop\")\r\n}\r\n\r\n\r\nSame as before, except anything other than green now gets a “stop” message. (Try some other values for light_status)\r\nelse if\r\n\r\n\r\nlight_status <- \"green\"\r\nif (light_status == \"green\") {\r\n  print(\"go\")\r\n} else if (light_status == \"orange\") {\r\n  print(\"stop if you are able to...\")\r\n} else {\r\n  print(\"stop\")\r\n}\r\n\r\n\r\nA green light still gets “go”, a red light still gets “stop”, but an orange light now gets a different message.\r\nThe traffic light works as it should! However… in coding you usually want to catch errors before they happen. Imagine the light cover is broken and the light is white. It might actually be a green, orange, or red. You will have to do a double take and determine which position the light is located and/or any further information available before deciding what to do. In the above example, anything other than green or orange would tell you to “stop”. We could expand this example by adding another else if statement:\r\n\r\n\r\nlight_status <- \"white\"\r\nif (light_status == \"green\") {\r\n  print(\"go\")\r\n} else if (light_status == \"orange\") {\r\n  print(\"stop if you are able to...\")\r\n} else if (light_status == \"red\") {\r\n  print(\"stop\")\r\n} else {\r\n  print(\"Warning: unexpected colour! Be careful and assess the situation...\")\r\n}\r\n\r\n\r\n(Try some other values for light_status)\r\nNow you have catered for all possible scenarios. You can add as many else if statements as you wish.\r\nifelse\r\nThere is a quicker way to code an if statement, whenever the situation is binary, i.e., there are only 2 options: if TRUE, do this, if FALSE, do that. There is a special built-in function in R to do this in one line:\r\nConsider the following 2-option if, else if statement, where there are no other scenarios possible:\r\n\r\n\r\nx <- 6\r\nif (x < 10) {\r\n  print(\"smaller than 10\")\r\n} else if (x >= 10) {\r\n  print(\"greater than 10\")\r\n}\r\n\r\n\r\nThis can be replaced with ifelse, syntax:\r\nifelse(test, yes, no)\r\nSo here, this would be:\r\n\r\n\r\nifelse(x < 10, print(\"smaller than 10\"), print(\"greater than 10\"))\r\n\r\n\r\n5 lines of code became 1. Please note to only use this function when you have a binary decision. If there are 3 or more options, you need the full-version if statement.\r\nA small note: note how R printed the output twice. Because ifelse is a function, it returns a value. So if you didn’t want R to print out the resulting value twice in the console, you would need to assign the output to a variable (using <- before ifelse).\r\nQuiz 3\r\n\r\nQuestion\r\nWhat will be the output of:\r\n\r\n\r\nx <- 20\r\nifelse(x == 20, print(\"FALSE\"), print(\"TRUE\"))\r\n\r\n\r\n\r\nTRUE\r\n\r\n\r\nFALSE\r\n\r\nSee Answer\r\nWhat will be the output of:\r\n\r\n\r\nx <- 20\r\nifelse(x == 20, print(\"FALSE\"), print(\"TRUE\"))\r\n\r\n\r\n\r\nTRUE\r\n\r\n\r\nFALSE\r\n\r\n\r\nControl flow exercises\r\n\r\nExercises\r\n\r\n# Exercise 4: Try and write an if statement, printing \"below 5\" if the input\r\n# value is <5, and \"5 up\" if 5 or above:\r\n\r\n\r\n# Exercise 5: This if statement doesn't work. Why not? Try to fix it:\r\ninput <- \"apple\"\r\nif (input == \"apple\") {\r\n  output <- \"This is an apple\"\r\n} else {\r\n  output <- \"This is not an apple or a pear\"\r\n} else if (input == \"pear\") {\r\n  output <- \"This is a pear\"\r\n}\r\nprint(output)\r\n\r\nExample solutions\r\n\r\n\r\n# Exercise 4: Try and write an if statement, printing \"below 5\" if the input\r\n# value is <5, and \"5 up\" if 5 or above:\r\nx <- 6\r\nif (x < 5) {\r\n  print(\"below 5\")\r\n} else if (x >= 5) {\r\n  print(\"5 up\")\r\n}\r\n\r\n# Exercise 5: This if statement doesn't work. Why not? Try to fix it:\r\n# Answer: else and else if were the wrong way around!\r\ninput <- \"apple\"\r\nif (input == \"apple\") {\r\n  output <- \"This is an apple\"\r\n} else if (input == \"pear\") {\r\n  output <- \"This is a pear\"\r\n} else {\r\n  output <- \"This is not an apple or a pear\"\r\n}\r\nprint(output)\r\n\r\n\r\n\r\nCombining loops/conditional statements\r\nYou can combine any of the above loops/conditional statements by nesting them.\r\nExample\r\nLet’s combine an if statement and for loop. Let’s expand the baby names examples from earlier, and only print a name if the name was in the top 10 in 2021. We’ll need to draw from a database to do this.\r\n\r\n\r\nbaby_names <- list(\"Oliver\", \"Leo\", \"Olivia\", \"Frank\")\r\ntop_10_2021_boys <- c(\"Noah\", \"Oliver\", \"George\", \"Arthur\", \"Muhammad\", \"Leo\", \"Harry\", \"Oscar\", \"Archie\", \"Henry\")\r\n\r\nfor (baby_name in baby_names) {\r\n  if (baby_name %in% top_10_2021_boys) {\r\n    print(baby_name)\r\n  }\r\n}\r\n\r\n\r\nNote the use of %in% here for the if statement only. The for loop knows how to use a regular in, as it iterates over the contents of the sequence. However, the if statement requires a relational operator with result TRUE or FALSE. To check whether a variable is included within a list or vector, you can use %in% as you can see here.\r\nQuiz 4\r\n\r\nQuestion\r\nI want to print a baby name if it’s in the top 10, but only if there are more than 5 babies in my database.\r\nWhat type of control flow structure would I start with (i.e. the first/outer-most one)?\r\n\r\nfor loop\r\n\r\n\r\nif statement\r\n\r\n\r\nwhile loop\r\n\r\nSee Answer\r\nI want to print a baby name if it’s in the top 10, but only if there are more than 5 babies in my database.\r\nWhat type of control flow structure would I start with (i.e. the first/outer-most one)?\r\n\r\nfor loop\r\n\r\n\r\nif statement\r\n\r\n\r\nwhile loop\r\n\r\n\r\nKeep track of your brackets\r\nIn nested loops, it is easily done to forget a bracket or have an extra one. In your script, you can place your cursor directly after one of the brackets, and the corresponding bracket will be highlighted.\r\nTo keep track of your nested loops, and all the brackets required, it also helps a lot to use the correct indentation. You can re-indent lines automically by highlighting a section of code, then Code -> Reindent Lines, or use the shortcut ctrl-I.\r\nAdvanced loop features\r\nBreak\r\nSometimes, you want the loop to run, but stop when a certain criterion is reached. In this scenario, you can use the break statement.\r\nAn example: you want to write out some data, but your system can’t handle more than 10 characters in the filename. Your for loop will print the output (in your real code, this would be a statement writing the data using the supplied filename), but it will first count the number of characters in your filename, and stop if the name is too long, so that your system doesn’t crash.\r\n\r\n\r\nfilenames <- c(\"filename1\", \"filename2\", \"fartoolongfilename3\", \"filename4\")\r\nfor (filename in filenames) {\r\n  if (nchar(filename) > 10) {\r\n    break\r\n  }\r\n  print(filename)\r\n}\r\n\r\n\r\nNext\r\nActually, we want the above loop to not just stop, but skip filenames that are too long and carry on with the next one! For this, you can use next.\r\n\r\n\r\nfilenames <- c(\"filename1\", \"filename2\", \"fartoolongfilename3\", \"filename4\")\r\nfor (filename in filenames) {\r\n  if (nchar(filename) > 10) {\r\n    next\r\n  }\r\n  print(filename)\r\n}\r\n\r\n\r\nLooping index\r\nAs you know, a for loop will run for all values within the sequence. It can be very useful to have access to the index that goes along with each value. For example, you can use this to store the output in a vector, or to use a counter. The index reflects the current iteration of the loop.\r\nThe following loop illustrates the difference between index and variable value:\r\n\r\n\r\nfilenames <- c(\"filename1\", \"filename2\", \"fartoolongfilename3\", \"filename4\")\r\nfor (index in 1:length(filenames)) {\r\n  print(paste0(\"index: \", index))\r\n  print(paste0(\"current element: \", filenames[index]))\r\n}\r\n\r\n\r\nAnd a numerical example, to show how you can use this to store results in a new vector:\r\n\r\n\r\ninput <- c(6, 3, 10, 2)\r\nresult <- c()\r\nfor (i in 1:length(input)) {\r\n  print(paste0(\"index: \", i))\r\n  print(paste0(\"current value: \", input[i]))\r\n  result[i] <- input[i] * 2\r\n}\r\n\r\n\r\nNote: seq_along() can be used in place of 1:length(input). This is a built-in method that, by default, creates a sequence of consecutive integers from 1 to the length of the object (vector, list, data frame).\r\n\r\n\r\ninput <- c(6, 3, 10, 2)\r\nseq_along(input)\r\n\r\n[1] 1 2 3 4\r\n\r\ni.e., the previous for loop can be written as:\r\n\r\n\r\ninput <- c(6, 3, 10, 2)\r\nresult <- c()\r\nfor (i in seq_along(input)) {\r\n  print(paste0(\"index: \", i))\r\n  print(paste0(\"current value: \", input[i]))\r\n  result[i] <- input[i] * 2\r\n}\r\n\r\n\r\nControl flow and loops excercises\r\n\r\nExercises\r\n\r\n\r\n# Exercise 6: Can you expand the baby names example to print \"This baby name is \r\n# in the top 10 girls names\" when this is the case?\r\n# (hint: you'll need to add another 'database': \r\n# top_10_2021_girls <- c(\"Olivia\", \"Amelia\", \"Isla\", \"Ava\", \"Ivy\", \"Freya\",\r\n# \"Lily\", \"Florence\", \"Mia\", \"Willow\")\r\n\r\n# This is a copy of the babies loop used in the training course:\r\nbaby_names <- list(\"Oliver\", \"Leo\", \"Olivia\", \"Frank\")\r\ntop_10_2021_boys <- c(\"Noah\", \"Oliver\", \"George\", \"Arthur\", \"Muhammad\", \"Leo\", \r\n                      \"Harry\", \"Oscar\", \"Archie\", \"Henry\")\r\n\r\nfor (baby_name in baby_names) {\r\n  if (baby_name %in% top_10_2021_boys) {\r\n    print(baby_name)\r\n  }\r\n}\r\n\r\n# Now expand this to print \"This baby name is in the top 10 girls names\" when \r\n# applicable:\r\n\r\n\r\n# Exercise 7: This nested loop doesn't work. Why not? Try to fix it:\r\n\r\nx <- 1:10\r\nfor (i in x) {\r\n  if (x < 3) {\r\n    print(paste0(\"i = \", i, \" = below 3\"))\r\n  } else {\r\n    print(paste0(\"i = \", i, \" = not below 3\"))\r\n  }\r\n}\r\n\r\n\r\n## The following are more advanced exercises:\r\n\r\n# Exercise 8: Can you write the apples example `while` loop as a `for` loop\r\n# instead? Try to use an index iterator, and print this each time the loop runs:\r\n\r\n# A repeat of the while loop used in the course:\r\nnum_apples <- 20\r\nwhile (num_apples > 2) {\r\n  print(\"Keep handing out apples\")\r\n  num_apples <- num_apples - 1\r\n}\r\nprint(paste0(\"Stop handing out apples, because you only have \",\r\n             num_apples, \" left\"))\r\n\r\n# Now try writing this as a for loop instead (requires some simple maths):\r\n\r\n\r\nExample solutions\r\n\r\n\r\n# Exercise 6: Can you expand the baby names example to print \"This baby name is \r\n# in the top 10 girls names\" when this is the case?\r\n# (hint: you'll need to add another 'database': \r\n# top_10_2021_girls <- c(\"Olivia\", \"Amelia\", \"Isla\", \"Ava\", \"Ivy\", \"Freya\",\r\n# \"Lily\", \"Florence\", \"Mia\", \"Willow\")\r\n\r\n# This is a copy of the babies loop used in the training course:\r\nbaby_names <- list(\"Oliver\", \"Leo\", \"Olivia\", \"Frank\")\r\ntop_10_2021_boys <- c(\"Noah\", \"Oliver\", \"George\", \"Arthur\", \"Muhammad\", \"Leo\", \r\n                      \"Harry\", \"Oscar\", \"Archie\", \"Henry\")\r\ntop_10_2021_girls <- c(\"Olivia\", \"Amelia\", \"Isla\", \"Ava\", \"Ivy\", \"Freya\",\r\n                       \"Lily\", \"Florence\", \"Mia\", \"Willow\")\r\n\r\nfor (baby_name in baby_names) {\r\n  if (baby_name %in% top_10_2021_boys) {\r\n    print(baby_name)\r\n  } else if (baby_name %in% top_10_2021_girls) {\r\n    print(baby_name)\r\n    print(\"This baby name is in the top 10 girls names\" )\r\n  }\r\n}\r\n\r\n# Exercise 7: This nested loop doesn't work. Why not? Try to fix it:\r\n# Answer: you used the wrong iterator (x vs i)!\r\nx <- 1:10\r\nfor (i in x) {\r\n  if (i < 3) {\r\n    print(paste0(\"i = \", i, \" = below 3\"))\r\n  } else {\r\n    print(paste0(\"i = \", i, \" = not below 3\"))\r\n  }\r\n}\r\n\r\n## The following are more advanced exercises:\r\n\r\n# Exercise 8: Can you write the apples example `while` loop as a `for` loop\r\n# instead? Try to use an index iterator, and print this each time the loop runs:\r\n\r\n# for loop:\r\nnum_apples <- 20\r\nnum_apples_to_keep <- 2\r\nnum_apples_hand_out <- 1\r\nfor (i in 1:((num_apples - num_apples_to_keep) / num_apples_hand_out)) {\r\n  print(paste0(\"Loop iteration: \", i))\r\n  print(paste0(\"Keep handing out apples, you still have \",\r\n               num_apples, \" left\"))\r\n  num_apples <- num_apples - num_apples_hand_out\r\n}\r\nprint(paste0(\"Stop handing out apples, because you only have \",\r\n             num_apples, \" left\"))\r\n\r\n# or, without the variables assigned in advance:\r\nnum_apples <- 20\r\nfor (i in 1:((num_apples - 2) / 1)) {\r\n  print(paste0(\"Loop iteration: \", i))\r\n  print(paste0(\"Keep handing out apples, you still have \",\r\n               num_apples, \" left\"))\r\n  num_apples <- num_apples - 1\r\n}\r\nprint(paste0(\"Stop handing out apples, because you only have \",\r\n             num_apples, \" left\"))\r\n\r\n\r\n\r\nAdditional resources\r\nFor more information about control flow see:\r\nAdvanced R: Control flow\r\nR Control Flow, Loops and Functions - course on LearningHub\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-25T18:26:55+01:00"
    },
    {
      "path": "functions.html",
      "title": "Functions in R",
      "author": [],
      "contents": "\r\n\r\nContents\r\nWhat are Functions?\r\nBenefit of Functions\r\nRepetitive vs functionalised code\r\nThree Elements of a Function\r\nAnalogy: Baking a Cake\r\nTwo main types of functions:\r\n\r\nHow to write and call a function\r\nNested functions\r\nWrapper Functions\r\n\r\nArguments\r\nRequired arguments\r\nDefault arguments\r\nQuiz 1\r\nAssignment\r\nOrder of arguments for existing and own functions\r\nFunctions intro excercises\r\n\r\nBest Practice Style for functions\r\nFunction name\r\nLines\r\nSpacing\r\nIndentation\r\nReturns\r\nAssignment\r\nArguments\r\nComments\r\nPiping %>% style/dplyr (Advanced)\r\nQuiz 2\r\n\r\nDocumentation (docstrings)\r\nFunction documentation: roxygen2\r\nQuiz 3\r\n\r\nPiping %>%\r\nWarnings and Errors\r\nWarnings\r\nErrors\r\nQuiz 3\r\nFunction exercises cd\r\n\r\nAdditional resources\r\n\r\nPrerequisites:\r\nRStudio and R installed on laptop\r\nPackages required: tidyverse\r\nBasic R coding skills\r\nWhat are Functions?\r\nCollection of statements orchestrated together to perform a specific operation.\r\nA function takes input (arguments), applies a method (code) to those arguments and returns the output.\r\nHopefully everyone in this session has experience of using functions when they code in R.\r\nE.g. sum() or mean().Note: Functions are objects, just as vectors are objects.\r\nBenefit of Functions\r\nReduce repetition\r\nReproducibility\r\nShorten code\r\nEditability\r\nTime-saving\r\nQuality\r\nRepetitive vs functionalised code\r\nWe want the average Petal Length/Petal Width ratio for the Sepal Lengths of less than 5, for each species separately (setosa, versicolor, virginica).\r\n\r\nWithout functions\r\n\r\n\r\nsetosa <- iris[iris$Species == \"setosa\", ]\r\nsetosa <- setosa[setosa$Sepal.Length < 7, ]\r\nsetosa$petal_length_width_ratio <- setosa$Petal.Length / setosa$Petal.Width\r\nmean(setosa$petal_length_width_ratio)\r\n\r\nversicolor <- iris[iris$Species == \"versicolor\", ]\r\nversicolor <- versicolor[versicolor$Sepal.Length < 7, ]\r\nversicolor$petal_length_width_ratio <-\r\nversicolor$Petal.Length / versicolor$Petal.Width\r\nmean(versicolor$petal_length_width_ratio)\r\n\r\nvirginica <- iris[iris$Species == \"virginica\", ]\r\nvirginica <- virginica[virginica$Sepal.Length < 7, ]\r\nvirginica$petal_length_width_ratio <-\r\nvirginica$Petal.Length / virginica$Petal.Width\r\nmean(virginica$petal_length_width_ratio)\r\n\r\n\r\nWith functions\r\n\r\n\r\niris_function <- function(data, species) {\r\n  data <- data[(data$Species == species) & (data$Sepal.Length < 7), ]\r\n  data$petal_length_width_ratio <- data$Petal.Length / data$Petal.Width\r\n  mean(data$petal_length_width_ratio)\r\n}\r\n\r\niris_function(iris, \"setosa\")\r\niris_function(iris, \"versicolor\")\r\niris_function(iris, \"virginica\")\r\n\r\n\r\n\r\nThree Elements of a Function\r\nArguments\r\nControls how you call the function.\r\nCan check it with: formals(function_name)\r\nBody\r\nThe code inside a function.\r\nCan check it with: body(function_name)\r\nEnvironment (Advanced)\r\nThe data structure that determines how the function finds the values associated with the names.\r\nCan check it with: environment(function_name)\r\nAnalogy: Baking a Cake\r\nA pipeline consists of multiple steps (involving functions) to achieve a desired output, just like how a cake recipe has steps/instructions to make a cake.\r\nLet’s simplify that and say that each step of a pipeline can a function a.k.a. a step of the recipe.\r\nFor Example - Cream together the butter and sugar in a mixing bowl with a wooden spoon until light and fluffy :\r\nThe ingredients (butter and sugar) are the arguments.\r\nThe bowl and spoon are your cooking tools, similar to existing functions that you want to use in your custom function. These may not be needed for all functions but can make what you are doing much easier!\r\nThe method of creaming the ingredients using the tools you need is the code body.\r\nThe output is creamed butter and sugar. This might not be the final product/exactly what you want if you are baking a cake but it is what you need for the next stage in the process.\r\nTwo main types of functions:\r\nNested functions (sub-functions)\r\nSingle, modular units of code (collection of statements) that do a single isolated process.\r\n\r\nWrapper functions\r\nFunctions that call other sub-functions/processes to perform multiple linked processes together.\r\n\r\nHow to write and call a function\r\n\r\n\r\n##### Standard syntax\r\nfunction_name <- function(argument) {\r\n  code\r\n}\r\n\r\n# If you don't want to assign the output of the function to a variable:\r\nfunction_name(argument = \"value\")\r\nfunction_name(\"value\")\r\n\r\n# If you want to assign the output of the function to a variable:\r\nfunction_output <- function_name(argument = \"value\")\r\nfunction_output <- function_name(\"value\")\r\n\r\n\r\nreturn()\r\nIn the syntax above, I have just used code as a stand in for the body of the function.\r\nWhen running a function, the code chunk will run, but only the last line will be output into the environment/saved when assigned to a variable. Some like to explicitly use return() to show what is being returned at the end of the function, but it is not necessary.\r\nAlso, print() statements will be output into the console.\r\nIt is worth being aware that any variables that are assigned inside a function, don’t automatically exist in the outside environment (can’t be retrieved after the function has run).\r\nWould recommend playing around with assignment with your functions.\r\nThere is a way to save more to the environment but that hasn’t been covered here.\r\n\r\n\r\nalphabet <- function() {\r\n  var_1 <- \"a\" # var_1 doesn't exist\r\n  var_2 <- \"b\" # is not output because it is\r\n  print(var_1) # because paste is used, var_1/a is output\r\n                  # but not saved when the variable is assigned \r\n  \"c\" # This is what is saved and assigned to the variable\r\n}\r\n\r\n\r\n\r\n\r\nalphabet()\r\n\r\n[1] \"a\"\r\n[1] \"c\"\r\n\r\n# The print is still printed to console, but what is the last line is not\r\nout <- alphabet()\r\n\r\n[1] \"a\"\r\n\r\n# The last line is saved into the environment in the \"out\" variable\r\nout\r\n\r\n[1] \"c\"\r\n\r\n# This doesn't exist outside the function, only within the function\r\n  # So cannot be retrieved\r\nvar_1\r\n\r\nError in eval(expr, envir, enclos): object 'var_1' not found\r\n\r\nCalling functions from packages\r\nBefore you can use a function that doesn’t exist in base r, you need to either:\r\nlibrary() the package that contains the function which loads the function into your environment\r\nor explicitly call the function from the package it is in using package_name::function_name()\r\nWe recommend using package_name::function_name() because it keeps your environment clearer and there is no potential confusion if there are multiple functions with the same name.\r\nPlus, it makes it easier for someone reading the code and to look into the correct documentation if necessary.\r\nThis works for existing/published packages or your own custom packages. However, for this training, as the functions aren’t packaged, we will rarely use that notation.\r\nNested functions\r\n\r\n\r\n## Example 1: Addition\r\nsum_two_numbers <- function(number_1, number_2) {\r\n  number_1 + number_2\r\n}\r\n\r\nsum_two_numbers(10, 3)\r\n\r\n[1] 13\r\n\r\nsum_two_numbers(number_1 = 11, number_2 = 22)\r\n\r\n[1] 33\r\n\r\n## Example 2: Temperature Conversions\r\n# Fahrenheit to Celsius\r\ndegree_F_to_C <- function(temp_F) {\r\n  (temp_F - 32) * 5 / 9\r\n}\r\n\r\n# Freezing point of water\r\ndegree_F_to_C(32)\r\n\r\n[1] 0\r\n\r\n# Boiling point of water\r\ndegree_F_to_C(212)\r\n\r\n[1] 100\r\n\r\n# Celsius to Kelvin\r\ndegree_C_to_K <- function(temp_C) {\r\n  temp_C + 273.15\r\n}\r\n\r\n# Freezing point of water in Kelvin\r\ndegree_C_to_K(0)\r\n\r\n[1] 273.15\r\n\r\nWrapper Functions\r\nMost functions will be wrapper functions of some sort. They will use existing published functions and/or custom functions to do more complex operations.\r\n\r\n\r\n## Example 1: Addition\r\n\r\ndouble_sum_two_numbers <- function(number_1, number_2) {\r\n  sum_two_numbers(number_1, number_2) * 2\r\n}\r\n\r\ndouble_sum_two_numbers(6, 5)\r\n\r\n[1] 22\r\n\r\n## Example 2: Temperature Conversions\r\n\r\n# Can nest related functions to run one after another\r\n# Freezing point of water in Kelvin\r\ndegree_C_to_K(degree_F_to_C(32))\r\n\r\n[1] 273.15\r\n\r\n# Or combine the functions/processes into a single wrapper function\r\n# This looks like more effort/code lines, but calling it is easier,\r\n  # it reads easier and you can add more processes to the function,\r\n    # not just nest the two function\r\ndegree_F_to_K <- function(temp_F) {\r\n  temp_C <- degree_F_to_C(temp_F)\r\n  degree_C_to_K(temp_C)\r\n}\r\n\r\n# And you can nest it within the function, so it is short, clear, easy to call\r\ndegree_F_to_K_nested <- function(temp_F) {\r\n  degree_C_to_K(degree_F_to_C(temp_F))\r\n}\r\n\r\n# Freezing point of water in Kelvin\r\ndegree_F_to_K(32)\r\n\r\n[1] 273.15\r\n\r\ndegree_F_to_K_nested(32)\r\n\r\n[1] 273.15\r\n\r\nArguments\r\nBy default, R will match arguments in the order they are used to the order they are in the function syntax.\r\n\r\n\r\nsimple_function <- function(arg_1, arg_2) {\r\n  print(paste(arg_1, arg_2, sep = \" - \"))\r\n}\r\n\r\n# Note the first argument relates to arg_1 as the argument name was not specified\r\n  # And vice versa\r\nsimple_function(\"this will be first\", \"this will be second\")\r\n\r\n[1] \"this will be first - this will be second\"\r\n\r\n# Note the first argument relates to arg_2 as it is specified and vice versa\r\nsimple_function(arg_2 = \"this will not be first\", \r\n                arg_1 = \"this will not be second\")\r\n\r\n[1] \"this will not be second - this will not be first\"\r\n\r\n# Another example\r\nminus_number <- function(starting_value, take_away) {\r\n  starting_value - take_away\r\n}\r\n\r\nminus_number(10, 5)\r\n\r\n[1] 5\r\n\r\nminus_number(5, 10)\r\n\r\n[1] -5\r\n\r\n# This is the same because you are specifying the arguments\r\nminus_number(take_away = 10, starting_value = 5)\r\n\r\n[1] -5\r\n\r\nRequired arguments\r\nIf an argument that is used in the function is missing, it will error.\r\nHowever, R executes functions in a lazy fashion. If arguments not required in the function are missing, the function will still be executed. Even though it doesn’t error, best practice is to make sure only arguments used in the code body are included.\r\n\r\n\r\n## Example 1: Addition\r\n\r\n# Function has 3 arguments, even though only 2 are used\r\ndouble_sum_two_numbers_three <- function(number_1, number_2, number_3) {\r\n  sum_two_numbers(number_1, number_2) * 2\r\n}\r\n\r\n# All three arguments are provided, even though number3 isn't used, but no error\r\ndouble_sum_two_numbers_three(6, 94, 20)\r\n\r\n[1] 200\r\n\r\n# This takes these two arguments as the first two arguments and\r\n  # as number3 isn't used, it doesn't matter that it is missing\r\n    # Still no error\r\ndouble_sum_two_numbers_three(88, -4)\r\n\r\n[1] 168\r\n\r\n\r\n\r\n# Number_1 is missing and there is no default\r\ndouble_sum_two_numbers_three(number_2 = -5, number3 = 12)\r\n\r\nError in double_sum_two_numbers_three(number_2 = -5, number3 = 12): unused argument (number3 = 12)\r\n\r\nDefault arguments\r\nIn all the examples above, we have only used arguments that require user inputs.\r\nHowever, there will be some arguments which have a default value so they do not need to be user defined every time when calling the function.\r\nDefaults can be set when the argument rarely need changing when running the function.\r\nFor very bespoke functions, these defaults can be very specific to their use-case.\r\nCommon default arguments are:\r\nNA\r\nNULL\r\n“”\r\n“generic title”\r\nTRUE/FALSE\r\n\r\n\r\n## Example 1: Addition\r\n\r\ndouble_sum_two_numbers_default <- function(number_1, number_2 = 0) {\r\n  sum_two_numbers(number_1, number_2)*2\r\n}\r\n\r\n# Just doubles the given argument (takes it as number_1)\r\n  # as number_2 is 0 by default\r\ndouble_sum_two_numbers_default(33)\r\n\r\n[1] 66\r\n\r\n\r\n\r\n# This is still missing number_1 as only number_2 had a default so errors\r\ndouble_sum_two_numbers_default(number_2 = 33)\r\n\r\nError in sum_two_numbers(number_1, number_2): argument \"number_1\" is missing, with no default\r\n\r\n\r\n\r\n## Example 2: Temperature Conversions\r\n\r\n# Here the default is 32 degree F aka 0 degree C\r\ndegree_F_to_K_default <- function(temp_F = 32) {\r\n  degree_C_to_K(degree_F_to_C(temp_F))\r\n}\r\n\r\n# So to use the default, can leave arguments blank\r\ndegree_F_to_K_default()\r\n\r\n[1] 273.15\r\n\r\nQuiz 1\r\n\r\nQuestion\r\nWhich of these functions has a default argument?\r\n\r\nfunction(first_name, surname) {\r\n\r\n\r\nfunction(age) {\r\n\r\n\r\nfunction(film_name, year = NA) {\r\n\r\n\r\nfunction(first_arg, default) {\r\n\r\nSee Answer\r\nWhich of these functions has a default argument?\r\n\r\nfunction(first_name, surname) {\r\n\r\n\r\nfunction(age) {\r\n\r\n\r\nfunction(film_name, year = NA) {\r\n\r\n\r\nfunction(first_arg, default) {\r\n\r\n\r\nAssignment\r\nWhen assigning something inside a function, the object will not be saved to the external environment, so you cannot access it after the function has finished running.\r\nOnly the final printout of the function (or return()) or anything that is run in print() is run.\r\n\r\n\r\n##### Example 1: Addition\r\n\r\nsum_two_numbers_assign <- function(number_1, number_2) {\r\n  sum <- number_1 + number_2\r\n}\r\n\r\n# Nothing printed out\r\nsum_two_numbers_assign(number_1 = 1, number_2 = 6)\r\n\r\n##### Example 2: Temperature Conversions\r\n\r\ndegree_F_to_K <- function(temp_F) {\r\n  temp_C <- degree_F_to_C(temp_F)\r\n  degree_C_to_K(temp_C)\r\n}\r\n\r\n# Freezing water in Kelvin returns the output\r\ndegree_F_to_K(temp_F = 32)\r\n\r\n[1] 273.15\r\n\r\ndegree_F_to_K_assign <- function(temp_F) {\r\n  temp_C <- degree_F_to_C(temp_F)\r\n  temp_K <- degree_C_to_K(temp_C)\r\n}\r\n\r\n# Freezing water in Kelvin will now not print the output\r\ndegree_F_to_K_assign(temp_F = 32)\r\n\r\n\r\nOrder of arguments for existing and own functions\r\nAs seen in previous examples, if no argument names are given, the function takes arguments in the order they are given.\r\nWhen writing your own (and is seen in most published functions), first should always be data.\r\nThis is especially important when using in dplyr pipes.\r\nUnfortunately, there are some older cases where that may not be the case, so it may be worth checking before you use them.\r\nMore information about this can be found in the piping section.\r\nFunctions intro excercises\r\n\r\nExercises\r\n\r\n\r\n##### Exercise 1 -\r\n\r\n# Create a function that will divide any number by 15\r\n\r\n\r\n##### Exercise 2 -\r\n\r\n# Create a function that will divide any vector, by any number, with the\r\n# default denominator value as 10.\r\n\r\n# Try assigning within the function and outside the function\r\n# to cause the output to be printed vs just being assigned\r\n# Hint: Think about the \"Environment\"\r\n\r\n##### Exercise 3 -\r\n\r\n# Create a function that computes weighted average using a vector containing\r\n# all values and a second vector containing their respective weights.\r\n# * there is already function in R that does it, but create your own\r\n\r\ndata <- c(15, 35, 50, 10)\r\nweighting <- c(3, 5, 3, 9)\r\n\r\n# Hint: the formula for weighted average is:\r\n  # divide the sum of (data times weighting) by the sum of the weights\r\n\r\n##### Exercise 4 -\r\n\r\n# Create a function that will multiply selected column name by a given number.\r\n# This should return just the multiplied dataframe column.\r\n# Default multiplier should be 5.\r\n\r\ndf <- data.frame(\r\n  a = 1:3,\r\n  b = 4:6,\r\n  c = 7:9)\r\n\r\n\r\nExample solutions\r\n\r\n\r\nlibrary(dplyr)\r\n\r\n##### Answer 1 -----\r\n\r\n#' Divide any number/numeric vector by 15\r\n#'\r\n#' @description Takes input of single number or vector of numbers and divides\r\n#' each element by 15.\r\n#'\r\n#' @param x numeric vector\r\n#'\r\n#' @return numeric vector\r\ndivide_15 <- function(x) {\r\n  x / 15\r\n}\r\n\r\ndivide_15(150)\r\ndivide_15(c(15, 45))\r\n\r\n\r\n##### Answer 2 -----\r\n\r\n#' Divide any numeric vector by any number.\r\n#'\r\n#' @description Divides a numeric vector by any number, default is 10.\r\n#'\r\n#' @param x numeric vector\r\n#' @param denominator numeric, default is 10\r\n#'\r\n#' @return numeric vector\r\ndivide <- function(x, denominator = 10) {\r\n  x / denominator\r\n}\r\n\r\ndivide(150)\r\ndivide(x = 150, denominator = 15)\r\ndivide(150, 15)\r\n\r\n# Output does not print to console when this is used - AVOID\r\ndivide <- function(x, denominator = 10) {\r\n  divided_num <- x / denominator\r\n}\r\n\r\n# Can save it as an intermediate and then return it but this is not best\r\n  # practice\r\ndivide <- function(x, denominator = 10) {\r\n  divided_num <- x / denominator\r\n  divided_num\r\n}\r\n\r\n# When the output of a function is saved as a variable\r\n  # the output is not printed to the console\r\ndivided <- divide(450)\r\n\r\n# But you can now retrieve it with the variable name\r\ndivided\r\n\r\n##### Answer 3 -----\r\n\r\n#' Computes weighted average.\r\n#'\r\n#' @description Computes weighted average from a vector of values,\r\n#' using a vector of respective weights.\r\n#'\r\n#' @param values numeric vector of values/data to be weighted\r\n#' @param weights numeric vector of weights\r\n#'\r\n#' @return numeric weighted average\r\ncompute_weighted_avg <- function(values, weights) {\r\n  sum(values * weights) / sum(weights)\r\n}\r\n\r\ncompute_weighted_avg(c(30, 50, 110, 40), weights = c(9, 8, 7, 6))\r\n\r\ndata <- c(15, 35, 50, 10)\r\nweighting <- c(3, 5, 3, 9)\r\n\r\ncompute_weighted_avg(data, weighting)\r\n\r\n##### Answer 4 -----\r\n\r\ndf <- data.frame(\r\n  a = 1:3,\r\n  b = 4:6,\r\n  c = 7:9)\r\n\r\n#' Multiply selected dataframe column by given number\r\n#'\r\n#' @description Multiply selected column by a given number.\r\n#' Default multiplier is 5.\r\n#'\r\n#' @param df dataframe with column to multiply\r\n#' @param col_name string name of column to multiply\r\n#' @param multiply_by numeric of magnitude to multiply column by, default is 5\r\n#'\r\n#' @return selected dataframe column multiplied by the given number\r\nselect_col_multiply <- function(df, col_name, multiply_by = 5) {\r\n  df[col_name] * multiply_by\r\n}\r\n\r\nselect_col_multiply(df, col_name = \"b\")\r\nselect_col_multiply(df, \"c\", 9)\r\n\r\n\r\n\r\nBest Practice Style for functions\r\nThere are many ways that you could write a function that technically would work.\r\nCode within a function should follow standard best practice style (see Tidyverse Style Guide).\r\nHowever, there are some best practice guidance to follow.\r\nKey point regardless of style you choose to follow: Consistency.\r\nNote: There are packages available to help you adhere to good style:\r\nWe recommend lintr. It doesn’t edit your code directly (as some others do, e.g. styler) but makes a descriptive list of where it recommends style improvements.\r\nThis package may not be perfect and is not a replacement for writing good code in the first place, or being critical about style in general.\r\n\r\n\r\ninstall.packages(\"lintr\")\r\n# This is the main function to check style in R scripts. Others exist too.\r\nlintr::lint(\"filename_filepath.R\")\r\n\r\n\r\nFunction name\r\nsnake_case\r\nLower case, numbers and underscores only (no full stops or hyphens)\r\nWords separated with _\r\n\r\nVery descriptive/meaningful\r\nIdeally contain a verb\r\nDoesn’t overwrite a commonly used/base function\r\nDo not start with a number or underscore\r\nLines\r\nIf the lines get too long (>79 characters), you can put the arguments on separate lines.\r\nCurly brackets: { should be the last thing on its line, } should be the first thing on its line.\r\nCode should be between the { and }, not on the same line.\r\nSpacing\r\nSpaces around the assignment (=, <-)\r\nSpace after comma in list of arguments\r\nNo space between function and (\r\nNo space between ( and first argument\r\nNo space between final argument and )\r\nSpace between ) and {\r\nIndentation\r\nCode should be indented 2 spaces (plus any further indents depending on the code).\r\nCtrl+i in RStudio manages this indentation for you.\r\nReturns\r\nR doesn’t need an explicit return().\r\nThe last line (idea/phrase) of a function is automatically returned.\r\nTidyverse style guide suggests not including the return(), but it has been used in some examples for clarity.\r\nConsistency is key.\r\nFurthermore, anything that is inside print() and warnings/errors will be returned to the console, but not saved as an output of the function.\r\nAssignment\r\nUse = inside a functions arguments (i.e. defining a default argument and specifying an argument when calling it).\r\nUse <- as normal best-practice inside the function code.\r\nArguments\r\nArgument names should follow similar rules to function names:\r\nDescriptive\r\nsnake_case\r\nConsistent argument names across functions can be helpful (e.g. df for a dataframe argument, x for an integer)\r\nLower case, numbers and underscores only (no full stops or hyphens)\r\nDo not start with a number or underscore\r\nIf the argument requires a string, use “string”, rather than ‘string’.\r\nUnless there is quote within a string: ‘this is a “quote” string’.\r\nFor general arguments, you don’t have to explicitly name the most obvious arguments (e.g. data) but it is recommended for custom functions and especially optional arguments. It can be very helpful for clarity in complex pipelines.\r\nComments\r\nIf using docstrings, minimal comments should be necessary for sub-functions.\r\nOnly comments explaining why things are being done should be included, instead of what is being done (same as general commenting style).\r\nIf docstrings are not used, should still add general comments on the function. At least for a title, description, any parameters and what is returned.\r\nPiping %>% style/dplyr (Advanced)\r\nThis relates to pipes (%>%) in code within and outside of functions.\r\n\r\n\r\n# If there is only one dplyr function, no pipes\r\ndplyr::filter(iris, Petal.Length > 6.5)\r\n\r\n  Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\r\n1          7.6         3.0          6.6         2.1 virginica\r\n2          7.7         3.8          6.7         2.2 virginica\r\n3          7.7         2.6          6.9         2.3 virginica\r\n4          7.7         2.8          6.7         2.0 virginica\r\n\r\n# If there are pipes, only one pipe per line and it is the last thing on the line\r\niris %>%\r\n  dplyr::filter(Petal.Length > 6.5) %>%\r\n  dplyr::select(Species, Petal.Length, Petal.Width)\r\n\r\n    Species Petal.Length Petal.Width\r\n1 virginica          6.6         2.1\r\n2 virginica          6.7         2.2\r\n3 virginica          6.9         2.3\r\n4 virginica          6.7         2.0\r\n\r\nQuiz 2\r\n\r\nQuestion\r\nWhat are good function and argument names?\r\n\r\nDoctorHouse(Patient1, Patient2)\r\n\r\n\r\ndoctorHouse(1stpatient, 2ndpatient)\r\n\r\n\r\ndoctorhouse(patientone, patienttwo)\r\n\r\n\r\ndoctor_house(first_patient, second_patient)\r\n\r\nSee Answer\r\nWhat are good function and argument names?\r\n\r\nDoctorHouse(Patient1, Patient2)\r\n\r\n\r\ndoctorHouse(1stpatient, 2ndpatient)\r\n\r\n\r\ndoctorhouse(patientone, patienttwo)\r\n\r\n\r\ndoctor_house(first_patient, second_patient)\r\n\r\n\r\nDocumentation (docstrings)\r\nEven if you don’t do technical Roxygen headers, you should still have correct level of comments describing what the function does: a title, description, any parameters and what is returned.\r\nHowever, we recommend giving any custom function the below Roxygen structure as it adds consistency, readability and can save time if you decide to package in the future.\r\nFunction documentation: roxygen2\r\nStandard format of headers to add to functions that automate creation of the function documentation.\r\nIn RStudio, put the cursor inside the function and either:\r\nCtrl+Shift+Alt+R\r\nOn toolbar, Code → Insert Roxygen skeleton\r\nSome parts are required, some are optional.\r\nRequired:\r\nTitle\r\nLike a short description\r\n\r\nDescription\r\nFull sentence structure explanation of what the function does and any important contextual information\r\n\r\nParameters\r\nShould have a descriptive name\r\nInclude what type/class of object is needed\r\nInclude any default values\r\n\r\nReturn\r\nWhat is the expected output (inc type/class)\r\n\r\nOptional:\r\nExamples\r\nCan add code for full, workable examples of the function to the header to help people use it\r\n\r\nAuthor\r\nAdd the authors name to the function\r\n\r\nExport\r\nAllows the function to be called one the function is packaged\r\n\r\nImport\r\nAny packages that need to be imported to the function to allow sub-functions to work\r\n\r\nThere are many other optional tags.\r\nNote: Best practice is to put sub-functions below the wrapper where it is used.\r\n\r\n\r\n##### Example 1 - Addition #####\r\n\r\n#' Sums two numbers\r\n#' \r\n#' @description Adds two numbers together and returns the sum.\r\n#' The numeric vectors need to be a multiple of each other (or the same).\r\n#'\r\n#' @param number_1 numeric vector\r\n#' @param number_2 numeric vector\r\n#'\r\n#' @return integer\r\nsum_two_numbers <- function(number_1, number_2) {\r\n  number_1 + number_2\r\n}\r\n\r\n##### Example 2 - Temperature Conversions #####\r\n\r\n#' Converts degrees Fahrenheit to degrees Celsius\r\n#'\r\n#' @description Converts degrees Fahrenheit to degrees Celsius,\r\n#' can be used on single number or numeric vector\r\n#' \r\n#' @param temp_F numeric vector of temperature in Fahrenheit\r\n#'\r\n#' @return numeric vector of temperature in Celsius\r\ndegree_F_to_C <- function(temp_F) {\r\n  (temp_F - 32) * 5 / 9\r\n}\r\n\r\n#' Converts degrees Fahrenheit to Kelvin\r\n#'\r\n#' @description Converts degrees Fahrenheit to Kelvin,\r\n#' can be used on single number or numeric vector\r\n#'\r\n#' @param temp_F numeric vector of temperature in Fahrenheit\r\n#'\r\n#' @return numeric vector of temperature in Kelvin\r\ndegree_F_to_K <- function(temp_F) {\r\n  temp_C <- degree_F_to_C(temp_F)\r\n  degree_C_to_K(temp_C)\r\n}\r\n\r\n#' Converts degrees Celsius to Kelvin\r\n#'\r\n#' @description Converts degrees Fahrenheit to Kelvin, \r\n#' can be used on single number or numeric vector\r\n#'\r\n#' @param temp_C numeric vector of temperature in Celsius\r\n#'\r\n#' @return numeric vector of temperature in Kelvin\r\ndegree_C_to_K <- function(temp_C) {\r\n  temp_C + 273.15\r\n}\r\n\r\n\r\nQuiz 3\r\n\r\nQuestion\r\nWhat parts of Roxygen header you should ALWAYS include?\r\n\r\nTitle, parameters, return\r\n\r\n\r\nTitle, example, return\r\n\r\n\r\nTitle, parameters, return, example\r\n\r\n\r\nDescription, parameters, example\r\n\r\nSee Answer\r\nWhat parts of Roxygen header you should ALWAYS include?\r\n\r\nTitle, parameters, return\r\n\r\n\r\nTitle, example, return\r\n\r\n\r\nTitle, parameters, return, example\r\n\r\n\r\nDescription, parameters, example\r\n\r\n\r\nPiping %>%\r\nThe pipe operator %>% (originally found in package magrittr) can be used as “and then” to call functions sequentially. It is most commonly found connecting dplyr functions together.\r\nThis replaces the need to save out intermediate results or nest functions.\r\nThese all do the same thing:\r\n\r\n\r\n# Make random vector\r\nx <- runif(100)\r\n\r\n# Intermediate saving - Should be avoided as much as possible\r\nout <- sd(x)\r\nout <- mean(out)\r\nsqrt(out)\r\n\r\n[1] 0.5446485\r\n\r\n# Nesting - Can get complicated when there are multiple arguments and brackets\r\nsqrt(mean(sd(x)))\r\n\r\n[1] 0.5446485\r\n\r\n# Piping - Best Practice\r\nx %>%\r\n  sd() %>%\r\n  mean() %>%\r\n  sqrt()\r\n\r\n[1] 0.5446485\r\n\r\nAs mentioned in a previous section, the order of arguments for dplyr piping is quite important. Data should be the first.\r\nWhen the functions are called in a pipe, it is assumed that the data from the previous level of the pipe is the default first argument, so it doesn’t need to be specified in each function.\r\n\r\n\r\n# Using a pre-loaded example dataset called iris\r\nhead(iris)\r\n\r\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\r\n1          5.1         3.5          1.4         0.2  setosa\r\n2          4.9         3.0          1.4         0.2  setosa\r\n3          4.7         3.2          1.3         0.2  setosa\r\n4          4.6         3.1          1.5         0.2  setosa\r\n5          5.0         3.6          1.4         0.2  setosa\r\n6          5.4         3.9          1.7         0.4  setosa\r\n\r\nselect_species_petal_width <- function(data, species_interest, petal_width) {\r\n\r\n  data %>%\r\n    dplyr::filter(Species == species_interest) %>%\r\n    dplyr::filter(Petal.Width < petal_width)\r\n  # These two filters do not have to be on separate lines \r\n    # but here they are split to demonstrate multiple pipes\r\n}\r\n\r\n\r\nhead(select_species_petal_width(iris, \"versicolor\", 1.5), 10)\r\n\r\n   Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\r\n1           7.0         3.2          4.7         1.4 versicolor\r\n2           5.5         2.3          4.0         1.3 versicolor\r\n3           5.7         2.8          4.5         1.3 versicolor\r\n4           4.9         2.4          3.3         1.0 versicolor\r\n5           6.6         2.9          4.6         1.3 versicolor\r\n6           5.2         2.7          3.9         1.4 versicolor\r\n7           5.0         2.0          3.5         1.0 versicolor\r\n8           6.0         2.2          4.0         1.0 versicolor\r\n9           6.1         2.9          4.7         1.4 versicolor\r\n10          5.6         2.9          3.6         1.3 versicolor\r\n\r\nYou can combine custom functions with existing functions, but you must be aware of the data argument. You may need to explicitly define that the data is to be used, using: ., followed by a comma to separate it from the next argument.\r\n\r\n\r\niris %>%\r\n  select_species_petal_width(\"versicolor\", 1.5) %>%\r\n  dplyr::mutate(sepal_width_to_length = Sepal.Width / Sepal.Length) %>%\r\n  utils::head(.)\r\n\r\n  Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\r\n1          7.0         3.2          4.7         1.4 versicolor\r\n2          5.5         2.3          4.0         1.3 versicolor\r\n3          5.7         2.8          4.5         1.3 versicolor\r\n4          4.9         2.4          3.3         1.0 versicolor\r\n5          6.6         2.9          4.6         1.3 versicolor\r\n6          5.2         2.7          3.9         1.4 versicolor\r\n  sepal_width_to_length\r\n1             0.4571429\r\n2             0.4181818\r\n3             0.4912281\r\n4             0.4897959\r\n5             0.4393939\r\n6             0.5192308\r\n\r\nWarnings and Errors\r\nIt can often be useful to add warnings and errors into your functions to help usability. Combine conditionals (if, else, ifelse or dplyr::case_when e.t.c.) with warnings/errors to only show in certain cases.\r\nUsing paste (or paste0) allows crafting of bespoke warning/error messages, such as what case you are testing.\r\nWarnings\r\nDoesn’t stop the code from running, but prints the warning to the console.\r\n\r\n\r\ndegree_F_to_C <- function(temp_F) {\r\n  if (temp_F < -460) {\r\n    warning(paste(\"Provided temperature (\",\r\n                  temp_F,\r\n                  \") is below absolute zero and thus, is impossible.\"))\r\n  }\r\n  (temp_F - 32) * 5 / 9\r\n}\r\n\r\ndegree_F_to_C(-666)\r\n\r\n[1] -387.7778\r\n\r\nErrors\r\nWill stop the code running at that point and print the error to the console.\r\n\r\n\r\ndegree_F_to_C <- function(temp_F) {\r\n  if (class(temp_F) != \"numeric\") {\r\n    stop(paste(\"Provided temperature in fahrenheit is not numeric. It is a\",\r\n               class(temp_F), \r\n               \"object.\"))\r\n  }\r\n  (temp_F - 32) * 5 / 9\r\n}\r\n\r\ndegree_F_to_C(\"200\")\r\n\r\nError in degree_F_to_C(\"200\"): Provided temperature in fahrenheit is not numeric. It is a character object.\r\n\r\nQuiz 3\r\n\r\nQuestion\r\nWhat are the correct functions to create a warning and an error? (select 2 answers)\r\n\r\nerror()\r\n\r\n\r\nstop()\r\n\r\n\r\nwarnings()\r\n\r\n\r\nSOMETHING_IS_VERY_WRONG()\r\n\r\n\r\nhalt()\r\n\r\n\r\nwarning()\r\n\r\nSee Answer\r\nWhat are the correct functions to create a warning and an error? (select 2 answers)\r\n\r\nerror()\r\n\r\n\r\nstop()\r\n\r\n\r\nwarnings()\r\n\r\n\r\nSOMETHING_IS_VERY_WRONG()\r\n\r\n\r\nhalt()\r\n\r\n\r\nwarning()\r\n\r\n\r\nFunction exercises cd\r\n\r\nExercises\r\n\r\n\r\n##### Exercise 5 -\r\n\r\n# Create a function that will add a new column to existing data frame by\r\n# multiplying another column of that data frame by 3. Default name for the new\r\n# column should be \"multiplied\".\r\n\r\n\r\n##### Exercise 6 -\r\n\r\n# Create a function that will compute average speed for each car brand in the\r\n# data frame based on distance driven and time it took. You can assume that\r\n# column names will be always the same for this dataset.\r\n\r\ncars <- data.frame(\r\n  brand = c(\"Audi\", \"BMW\", \"Toyota\"),\r\n  distance = 4:6, # in miles\r\n  travel_time = 7:9) # in hours\r\n\r\n# Hint: speed equals distance over time\r\n\r\n# EXTRA: Create a function that will tell which car is the fastest?\r\n\r\n# Try adding a warning and an error to your functions\r\n\r\n\r\nExample solutions\r\n\r\n\r\n#' Add new column to dataframe which is 3x multiplication of an existing column\r\n#'\r\n#' @description Adds a new column to existing data frame by multiplying another\r\n#' column of that data frame by 3.\r\n#' Default name for the new column should be \"multiplied\".\r\n#'\r\n#' @param df dataframe with at least one numeric column to be multiplied\r\n#' @param col_name string name of numeric column to be multiplied\r\n#' @param new_col_name string name of new column, default is \"multiplied\"\r\n#'\r\n#' @return dataframe with extra column\r\nnew_col_mulitplied <- function(df, col_name, new_col_name = \"multiplied\") {\r\n  df[new_col_name] <- df[col_name] * 3\r\n  df\r\n}\r\n\r\nnew_col_mulitplied(df, col_name = \"b\")\r\nnew_col_mulitplied(df, col_name = \"a\", \"any_colname\")\r\n\r\n\r\n##### Extra - Answer 6 -----\r\n\r\ncars <- data.frame(\r\n  brand = c(\"Audi\", \"BMW\", \"Toyota\"),\r\n  distance = 4:6, # in miles\r\n  travel_time = 7:9) # in hours\r\n\r\n#' Calculate car speed\r\n#'\r\n#' @description Calculates speed of car from distance and travel time\r\n#'\r\n#' @param df dataframe of cars with at least columns of distance and travel_time\r\n#'\r\n#' @return dataframe with new column for speed\r\ncar_speed <- function(df) {\r\n  df$speed <- df$distance / df$travel_time\r\n  df\r\n}\r\n\r\ncar_speed(cars)\r\n\r\n# EXTRA\r\n\r\n#' Find the name of the fastest car\r\n#' \r\n#' @description Using variables of distance and travel_time, speed is calculated\r\n#' and car brand name of the fastest speed is returned.\r\n#'\r\n#' @param df dataframe with columns called distance, travel_time and brand\r\n#'\r\n#' @return name of fastest car as a string\r\n#' @export\r\nfind_fastest_car <- function(df) {\r\n  df <- car_speed(df)\r\n  df$brand[df$speed == max(df$speed)]\r\n}\r\n\r\nfind_fastest_car(cars)\r\n\r\n\r\n\r\nAdditional resources\r\nFor more information see:\r\nAdvanced functions - next tutorial\r\nR Control Flow, Loops and Functions - course on LearningHub\r\nModular programming in R and Python - course on LearningHub\r\nNote that LearningHub resources are only available for colleagues from ONS and other government departments.\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-25T18:27:07+01:00"
    },
    {
      "path": "glossary.html",
      "title": "Glossary",
      "author": [],
      "contents": "\r\nGlossary of terms that appear across the tutorials:\r\n\r\n\r\nJargon\r\n\r\n\r\nDefinition\r\n\r\n\r\nLinks to further info\r\n\r\n\r\nArgument\r\n\r\n\r\nThe input(s) to a function to make it do what you want.\r\n\r\n\r\nArgument\r\n\r\n\r\nConsole\r\n\r\n\r\nWhere the code runs. You can interact directly with the console (type in it). Or when you run code in the script, it prints/runs here. Printouts also are show here.\r\n\r\n\r\nConsole\r\n\r\n\r\nEnvironment\r\n\r\n\r\nGenerally talking about the global environment. Contains all the variables, data and functions that are accessible to the user.\r\n\r\n\r\nEnvironment\r\n\r\n\r\nFile path\r\n\r\n\r\nLocation/address of your folders, sub-folders and files inside your drives. Can be see in Window’s File Explorer address bar. Used to find and read in objects/data and save out objects/data.\r\n\r\n\r\nFile path\r\n\r\n\r\nIndent\r\n\r\n\r\nHow many tabs/spaces away from the right hand side of the script the code is written. R doesn’t generally mind about indents but there is best practice.\r\n\r\n\r\nIndent\r\n\r\n\r\nParentheses, Brackets, Bracers\r\n\r\n\r\nRound brackets (), Curly brackets {}, Square brackets []\r\n\r\n\r\nParentheses, Brackets, Bracers\r\n\r\n\r\nPipe\r\n\r\n\r\nThe operator %>% from magrittr which allows functions to be called on dataframes in a sequential order.\r\n\r\n\r\nPipe\r\n\r\n\r\nPrint/Printout\r\n\r\n\r\nOutputs text, data etc to the console.\r\n\r\n\r\nPrint/Printout\r\n\r\n\r\nReturn\r\n\r\n\r\nColloquially similar to printout but when regarding a function.\r\n\r\n\r\nReturn\r\n\r\n\r\nScript\r\n\r\n\r\nA text file containing code (a sequence of commands) that can be edited and saved. Code runs in the console.\r\n\r\n\r\nScript\r\n\r\n\r\nSyntax\r\n\r\n\r\nAkin to a languages grammar. A fancy way of saying how something in the code is written to get it to do what you want. The rules of writing code. Differs across different programming languages.\r\n\r\n\r\nSyntax\r\n\r\n\r\nTerminal\r\n\r\n\r\nProvides access to the system shell (command line interface with things like file explorer, Git).\r\n\r\n\r\nTerminal\r\n\r\n\r\nVariable assignment, Assign a variable\r\n\r\n\r\nSave something (data, value, function etc) to a variable, primarily using <- or =, so that it is availble in the environment to be used in the code.\r\n\r\n\r\nVariable assignment, Assign a variable\r\n\r\n\r\nWorking directory\r\n\r\n\r\nFolder where you are working. It’s the place (the environment) where you have to store your files of your project in order to load them or where your R objects will be saved.\r\n\r\n\r\nWorking directory\r\n\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-25T18:27:08+01:00"
    },
    {
      "path": "index.html",
      "title": "RAPID training",
      "description": "Training materials for building Reproducible Analytical Pipelines\n",
      "author": [],
      "contents": "\r\nAbout this page\r\nThis page contains training resources for building Reproducible Analytical Pipelines. They are aimed at Government Analysts wanting to implement best practice into their work.\r\nPage is under construction and more resources will be gradually added. Please come back in a few weeks!\r\nComing soon:\r\nGit training\r\nAdvanced control flow in R\r\nHow to write a good README\r\nSpreadsheet automation in R\r\nand more!\r\nWhat is RAP and why you should implemment it\r\nReproducible analytical pipelines (RAP) have a range of benefits – from increasing efficiency to improving business continuity.\r\nHow implementing RAP can benefit you and your team?\r\nReduced risks and improved quality\r\nLowers the risk of human error, automated checks and audit trail ensure mistakes are never repeated, all of which boost organisation’s trustworthiness and reputation.\r\nYou can read more about RAP introduction in the civil service in Analysis Function strategy and Goldacre review.\r\nIncreased resilience and business continuity\r\nWell-documented code stored in accessible location can be used by new analysts with minimal preparation, which makes the team more resilient when people move roles or fall ill. \r\nIncreased efficiency\r\nMore time to spend on exploring new ideas or personal development, and less time on copy/pasting and manual checks.\r\nIncreased collaboration\r\nSharing code on Git allows analysts to reuse code between projects, which reduces time to create new analytical pipelines and allows to quickly implement trusted solutions.\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-25T22:43:25+01:00"
    },
    {
      "path": "packages.html",
      "title": "Packages and unit testing",
      "author": [],
      "contents": "\r\n\r\nContents\r\nWhat is a package and when do we need one?\r\nQuiz 1\r\n\r\nPackage structure and setup\r\nPackage name\r\nCreating basic structure\r\nQuiz 2\r\n\r\nFunctions and installing/testing your package\r\nAdding functions to your package\r\nTrying out functions from your package\r\nPackage exercises - building a package\r\n\r\nPackage documentation\r\nMinimum functionality and installing your package\r\nFunctions’ docstrings\r\nExample roxygen docstrings\r\nOptional roxygen tags (advanced content)\r\nProduce documentation\r\nDocumentation exercises\r\n\r\nUnit testing and Quality Assurance\r\nWhat are unit tests?\r\nWhere to put unit tests in a package?\r\nHow to write unit tests with testthat?\r\nWhat should you be testing?\r\nHow many tests for a function? (optional)\r\nTesting your package\r\nUnExported functions (optional)\r\nQuality Assurance\r\nTesting excercises\r\n\r\nHow to share your package?\r\nAdditional resources\r\n\r\nPrerequisities\r\nYou will need devtools and roxygen packages installed for this tutorial.\r\n\r\n\r\ninstall.packages(c(\"devtools\", \"roxygen\"), dependencies = TRUE, type = \"win.binary\")\r\n\r\n\r\nWhat is a package and when do we need one?\r\nTo put simply a package is a collection of functions that we can load into our workspace and use. Base R contains many functions already, but loading packages extends R functionality. Some of the most popular packages in HAPI include dplyr for data manipulation and ggplot2 for creating charts.\r\nIs a package only way to store and load your functions? No. Depending on the size and complexity of your project you should select one of the following options to store your functions.\r\nSimplest option is to have functions stored in the body of your scipt, load them into the global environment (you’ll see them in the top right corner in R Studio) and use. This will only be good solution for a very small project.\r\nYou can save all of your functions in a single .R script (e.g. “functions.R”) and load them in into analytical script using source() function e.g.:\r\n\r\n\r\nsource(\"functions.R\")\r\n\r\n\r\nYou can create a package that will contain all your functions. Benefits of that solution include good dependency management (using other packages, requiring specific versions etc.), simple implementation of unit tests and good documentation solutions that make it easier for other people to use your functions. Package is often the best solution for more complex analyses.\r\nQuiz 1\r\n\r\nQuestion\r\nWhat do you class as a small project?\r\n\r\nProject with less than 10 bespoke functions\r\n\r\n\r\nProject that comfortable fits in a single script\r\n\r\n\r\nProject producing less than 10 tables\r\n\r\n\r\nProject that uses no more than 3 scripts for analysis\r\n\r\nSee Answer\r\nWhat do you class as a small project?\r\n\r\nProject with less than 10 bespoke functions\r\n\r\n\r\nProject that comfortable fits in a single script\r\n\r\n\r\nProject producing less than 10 tables\r\n\r\n\r\nProject that uses no more than 3 scripts for analysis\r\n\r\nOur guidance for small projects is aproppriate for projects that would fit in a single script.\r\n\r\nPackage structure and setup\r\nPackage name\r\nPackage name should consist of letters and numbers and be informative. You can’t use underscores in a package name, but . are allowed. Make sure that your name is unique to avoid conflicts with existing packages.\r\nCreating basic structure\r\nDevtools create() function creates package folders in current directory.\r\n\r\n\r\ndevtools::create(\"pckgname\")\r\n\r\n\r\nThe structure created this way includes folder called R (for all your functions) and DESCRIPTION and NAMESPACE files.\r\n\r\n\r\ndir(\"pckgname\")\r\n\r\n[1] \"DESCRIPTION\" \"NAMESPACE\"   \"R\"           \"tests\"      \r\n\r\nDESCRIPTION file can be edited manually (e.g. using notepad) and should contain:\r\nTitle of the package\r\nAny dependencies, including versions (if needed)\r\nLicense\r\nAuthors@R field should include details of authors, contributors, and copyright holders\r\nNAMESPACE file should not be edited manually, it will be updated automatically when you document your package.\r\nThis a basic structure of a package. In analytical pipeline, your package is something that stores all the functions (can store few more things as you will see later), but does not include the main pipeline itself. Your overall project structure will look as follows:\r\nproject/\r\n  pckgname/\r\n    DESCRIPTION\r\n    NAMESPACE\r\n    R/\r\n      analytical_functions.R\r\n      data_processing_functions.R\r\n      super_complex_modelling_functions.R\r\n\r\n  README.txt\r\n  config.yaml OR config.R\r\n  main.R\r\nThis is the basic package structure, there will be few more things in the package that you’ll learn about in the further sections.\r\nQuiz 2\r\n\r\nQuestion\r\nWhat would be a good name for your new package?\r\n\r\ndplyr\r\n\r\n\r\nquarterly_births\r\n\r\n\r\nqrt.birth\r\n\r\nSee Answer\r\nWhat would be a good name for your new package?\r\n\r\ndplyr\r\n\r\n\r\nquarterly_births\r\n\r\n\r\nqrt.birth\r\n\r\n\r\nFunctions and installing/testing your package\r\nAdding functions to your package\r\nFunctions need to be stored in R/ folder inside the package. You can have individual files for each function or store multiple functions in a single file. Files containing a single function should have the same name as that function. When you store couple of functions together they should be grouped with similar functions (e.g. import functions) and files should have informative names (e.g. data_import.R). The easiest way to add functions to a package is to create an R script and save it in the project/pckgname/R folder.\r\nYou can simply open a new R script, name it cool_functions.R and save in your /R subfolder inside the package folder. You can also create new R script using:\r\n\r\n\r\nsetwd(\"pckgname\") # you need to be in the package folder -> so first we move into the package\r\nusethis::use_r(\"cool_functions\")    # creates and opens R/cool_functions.R\r\n\r\n\r\n*Note that using setwd() in a chunk only works within that chunk. So your wd outside the chunk stays the same - and other chunks are going to use the global working directory instead.\r\nYou can paste in the following function or create your own.\r\n\r\n\r\nadd_3 <- function(x) {\r\n  x + 3\r\n}\r\n\r\n\r\nTrying out functions from your package\r\nNow that we have something in our package, let’s try installing it. To do so you need to be in your project directory (e.g. “D:/project/”) if you aren’t use setwd(“D:/project/”) in R console to change your working directory.\r\nTo install your package:\r\n\r\n\r\ndevtools::install(\"pckgname\")\r\n\r\n* checking for file 'D:\\github\\web_raptraining\\pckgname/DESCRIPTION' ... OK\r\n* preparing 'pckgname':\r\n* checking DESCRIPTION meta-information ... OK\r\n* checking for LF line-endings in source and make files and shell scripts\r\n* checking for empty or unneeded directories\r\nRemoved empty directory 'pckgname/tests/testthat'\r\n* building 'pckgname_0.0.0.9000.tar.gz'\r\n\r\nRunning \"C:/MY_RST~1/R-41~1.3/bin/x64/Rcmd.exe\" INSTALL \\\r\n  \"C:\\Users\\delonp\\AppData\\Local\\Temp\\RtmpsJYU42/pckgname_0.0.0.9000.tar.gz\" \\\r\n  --install-tests \r\n* installing to library 'C:/My_RStudio/pckgs'\r\n* installing *source* package 'pckgname' ...\r\n** using staged installation\r\n** R\r\n** tests\r\n** byte-compile and prepare package for lazy loading\r\n** help\r\nNo man pages found in package  'pckgname' \r\n*** installing help indices\r\n** building package indices\r\n** testing if installed package can be loaded from temporary location\r\n*** arch - i386\r\n*** arch - x64\r\n** testing if installed package can be loaded from final location\r\n*** arch - i386\r\n*** arch - x64\r\n** testing if installed package keeps a record of temporary installation path\r\n* DONE (pckgname)\r\n\r\nOnce the package is installed, library it in to use its functions (as with any package!).\r\n\r\n\r\nlibrary(pckgname)\r\nadd_3(1)\r\n\r\nError in add_3(1): could not find function \"add_3\"\r\n\r\nAnnoyingly this does not work!\r\nWe will need to add few more steps for it to work, but in the meantime we can use a different function to allow us try out our functions at the development stage.\r\n\r\n\r\ndevtools::load_all(\"pckgname\")\r\nadd_3(1)\r\n\r\n[1] 4\r\n\r\nWorked as a charm! Using load_all is the fastest way to try out the functionality of your new functions, so you’re likely to be using it often while building your package.\r\nOk, but what do you need to do for it to work properly? You’ll have to add proper documentation to your functions.\r\nPackage exercises - building a package\r\nThese were designed for small group/paired coding, but you should ba able to complete these on your own based on the information from above sections.\r\n\r\nExercises\r\n\r\n\r\n# 1. Create your own package ----\r\n# Create your own package and inspect the directory created in win explorer or\r\n# in R \"files\" window on the bottom right. \r\n\r\n\r\n# 2. Add an .R script to the R folder of the package, that will store your \r\n# functions. You can do it manually or using usethis package.\r\n\r\n\r\n# 3. Add a simple function to your package.\r\n\r\n\r\n# 4. Install and library in your package and try calling the function.\r\n\r\n\r\n# 5. Use appropriate devtools:: function (which one?) to load the package and\r\n# try calling your function.\r\n\r\n\r\nSolutions\r\n\r\n\r\n# 1. Create your own package ----\r\n# Create your own package and inspect the directory created in win explorer or\r\n# in R \"files\" window on the bottom right. \r\ndevtools::create(\"my.awesome.package\")\r\n\r\n# 2. Add an .R script to the R folder of the package, that will store your \r\n# functions. You can do it manually or using usethis package.\r\nsetwd(\"my.awesome.package\") \r\nusethis::use_r(\"my_functions\") \r\n\r\n# 3. Add a simple function to your package. \r\nadd_3 <- function(x) {\r\n  x + 3\r\n}\r\n\r\n# You can simply copy/paste the above into my_functions script OR run:\r\ndump(\"add_3\", file = \"my.awesome.package/R/my_functions.R\")\r\n\r\n# 4. Install and library in your package and try calling the function.\r\n# make sure to remove add_3 from global environment if you can see it there (Environment tab in R Studio)\r\ndevtools::install(\"my.awesome.package\")\r\nlibrary(my.awesome.package)\r\n\r\nadd_3(1)\r\n# this should give you an error!\r\n\r\n# 5. Use appropriate devtools:: function (which one?) to load the package and\r\n# try calling your function.\r\ndevtools::load_all(\"my.awesome.package\")\r\n\r\nadd_3(1)\r\n# this should work!\r\n\r\n\r\n\r\nPackage documentation\r\nIndividual functions in a package need their own documentation. You should also include some documentation for functions even for smaller projects, but for packages they need to follow a specific format. For R packages roxygen allows us to build clean documentation. For functions these “comments” are called docstrings.\r\nThe roxygen headers are included in the same script as the function code. You use roxygen comments #’ to identify a line as part of the roxygen header.\r\nMinimum functionality and installing your package\r\nAs a bare minimum your functions need an @export tag to work. Try adding the following line above your function in the “test_functions.R” script:\r\n\r\n\r\n#' @export\r\n\r\n\r\nFor the package to work you need to create documentation with devtools::document() and then install your package using devtools::install. Note that without the export tag devtools::document() the package would not export any functions, so you still wouldn’t be able to use them.\r\n\r\n\r\ndevtools::document(\"pckgname\")\r\n\r\n\r\nYou should see the message “Writing NAMESPACE”. Open the NAMESPACE file and see what changed.\r\nFirst line has not changed, but now there is a new line telling the package to export add_3 function. All the functions you want users to get from your package need to be exported and appear in the NAMESPACE.\r\nNow, when you install your package you can library it in and use it’s functions.\r\nFunctions’ docstrings\r\nThe first three lines of the header have special meaning and you don’t need to use tags to identify them. The first three lines are title, description and details. Since you don’t use any tags to identify the first three lines, it is necessary that you separate them by a new line. For example:\r\n\r\n\r\n#' Title of the function\r\n#'\r\n#' Description of what function does\r\n#'\r\n#' Details\r\n\r\n\r\nOne of the most important aspects of a function to document are the arguments. With roxygen you specify them with the @param tag. You follow the tag with the argument name and then any details the user needs to know. If there is a lot of information that you need to provide about an argument you might want to consider putting this in the details section instead.\r\n\r\n\r\n#' @param x Description of the x argument\r\n\r\n\r\nReturn header will the users what to expect as an output of the function.\r\n\r\n\r\n#' @return Description of the output\r\n\r\n\r\nOnly exported functions will be loaded and directly accessible to users when they load a package, so make sure to add the export tags.\r\n\r\n\r\n#' @export\r\n\r\n\r\nExample roxygen docstrings\r\nThis is minimal documentation that each function should have:\r\n* title\r\n* description\r\n* params\r\n* return\r\n* export tag (if exported)\r\n\r\n\r\n#' Add three\r\n#' \r\n#' Computes sum of given number and 3\r\n#' \r\n#' @param x Numeric vector\r\n#' \r\n#' @return Numeric vector with values increased by 3\r\n\r\n\r\nAnother tag that you’ll likely use often is @import tag, which will attach other packages that your functions use and make sure they are installed when your package is installed.\r\n\r\n\r\n#' @import purrr\r\n#' @import dplyr\r\n\r\n\r\nOptional roxygen tags (advanced content)\r\nYou can also include examples in roxygen header\r\n\r\n\r\n#' @example\r\n#' \\dontrun{\r\n#'   mean(5)\r\n#'}\r\n\r\n\r\nWhen you write documentation you may want to format the text to look like code, link to other functions or, particularly for return objects, format as a bulleted list. You can do this using special formatting:\r\nFor code you use:\r\nTo link to other functions you use:\r\nNote the package name is only required if the function is not in your package.\r\nTo include an unordered list you use:\r\nInside the brackets you mark new items with\r\nfollowed by the item text.\r\n\r\n\r\n#' @return This function returns a \\code{data.frame} including columns:\r\n#' \\itemize{\r\n#'  \\item colname\r\n#'  \\item colname2\r\n#' }\r\n\r\n\r\nadd author\r\n\r\n\r\n#' @author My Name <myemail@example.com>\r\n\r\n\r\nif you want to link to other functions\r\n\r\n\r\n#' @seealso \\code{\\link[packagename]{functioname}}\r\n\r\n\r\nIn addition to the individual functions you can also document the whole package.\r\nWhen you document a package you can use all of the same tags as for functions but the problem that you have is that there is no R code to document. Instead you put the keyword “_PACKAGE” underneath your package header.\r\nThe script should be saved in R directory in file with package name, e.g. pckgname.R\r\n\r\n\r\n#' Title\r\n#'\r\n#' Description\r\n#'\r\n#' @docType package\r\n#' @name pckgname\r\n\"_PACKAGE\"\r\n\r\n[1] \"_PACKAGE\"\r\n\r\nProduce documentation\r\nOnce you created roxygen headers you can create documentation for your package.\r\n\r\n\r\n# Generate package documentation\r\ndevtools::document(\"pckgname\")\r\n\r\n# Examine the contents of the man directory\r\ndir(\"pckgname/man\")\r\n\r\n# View the documentation for the package and it's function\r\nhelp(\"pckgname\")\r\n\r\n# Update the package loaded in your workspace\r\ndevtools::load_all(\"pckgnmme\")\r\n\r\n\r\nUsing roxygen comments will help you build code documentation when you run\r\ndevtools::document function and will update NAMESPACE file, but not the\r\nDESCRIPTION file. You can update the description file manually. For instance, roxygen won’t update the Dependencies or Imports in the DESCRIPTION file.\r\nDocumentation exercises\r\n\r\nExercises\r\n\r\n\r\n# 6. Add roxygen comments to your .R script, above the function definition. \r\n# Then document and update the package loaded into your environment with load_all.\r\n\r\ndevtools::document(\"\")\r\ndevtools::load_all(\"\")\r\n# Now see what happens if you try finding help on your function.\r\n\r\n?your_function_name\r\n\r\n# 7. Add one of the functions from the previous session to your package and \r\n# create roxygen documentation for it.\r\n\r\n\r\nExample solutions\r\n\r\n\r\n# 6. Add roxygen comments to your .R script, above the function definition. \r\n# Then document and update the package loaded into your environment with load_all.\r\n\r\n#' Add three\r\n#'\r\n#' @param x numeric vector\r\n#'\r\n#' @return numeric vetor with values increased by 3\r\n#' @export\r\n\r\nadd_3 <- function(x) {\r\n  x + 3\r\n}\r\n\r\ndevtools::document(\"my.awesome.package\")\r\ndevtools::load_all(\"my.awesome.package\")\r\n# Now see what happens if you try finding help on your function.\r\n\r\n?add_3\r\n\r\n# 7. Add one of the functions from the previous session to your package and \r\n# create roxygen documentation for it.\r\n\r\n\r\n\r\nUnit testing and Quality Assurance\r\nWhat are unit tests?\r\nUnit tests check whether functions do what is expected of them. No more no less. Ideally, you would like a 100% of test coverage, which means that every functions has tests that check for every eventuality. More realistically 60-70% test coverage is very good.\r\nTo create unit tests, you’ll produce dummy data and run your function using this data to check if it produces expected output. Not as difficult as it sounds is it?\r\nWhere to put unit tests in a package?\r\nSetting up folder for unit tests\r\n\r\n\r\nusethis::use_testthat() # your wd should be in the package\r\n\r\n\r\nYou could also create these folders manually - let’s have a look how it should look like.\r\n\r\n\r\ndir(\"pckgname\")\r\n\r\n[1] \"DESCRIPTION\" \"NAMESPACE\"   \"R\"           \"tests\"      \r\n\r\nYou can see a folder called tests - let’s see what’s inside.\r\n\r\n\r\ndir(\"pckgname/tests\")\r\n\r\n[1] \"testthat\"   \"testthat.R\"\r\n\r\nHow to write unit tests with testthat?\r\nFor each function you’ll need a separate .R file named test-function_name.R. Inside you create test data and output that function should produce for the test data you create within the test script. Then you compare the expected output (that is hardcoded) with output of the function.\r\nYou can create testing scripts manually - just as describe above or for function called “function_name” you can use:\r\n\r\n\r\nusethis::use_test(\"function_name\") # creates and opens tests/testthat/test-function_name.R\r\n\r\n\r\nIf your functions are grouped in an R script together e.g. pckgname/R/data_processing.R your test files should be named the same as the function files, e.g.:\r\n\r\n\r\nusethis::use_test(\"data_processing\") # creates and opens tests/testthat/test-data_processing.R\r\n\r\n\r\nYou can use expect_equal(), expect_equivalent() and expect_identical() in order to test whether the output of a function is as expected. These three functions all have slightly different functionality:\r\ntestthat::expect_identical() checks that the values, attributes, and type of both objects are the same.\r\ntestthat::expect_equal() checks that the values, and attributes of both objects are the same. You can adjust how testthat::strict expect_equal() is by adjusting the tolerance parameter.\r\ntestthat::expect_equivalent() checks that the values, of both objects are the same.\r\nSee example of what test script should contain:\r\n\r\n\r\ntest_data <- c(2, 3)\r\nexpected_output <- c(5, 6)\r\nfunction_output <- add_3(test_data)\r\n\r\n\r\ntestthat::test_that(\"Checking expected outcome matches outcome for add_3 function\", {\r\n  testthat::expect_identical(function_output, expected_output)\r\n})\r\n\r\n\r\nWhat should you be testing?\r\nEverything that is crucial for the function to work. It is not possible to test for every possibility, but checking how function will handle various combination of arguments, extra columns or different types of values (e.g. 0, NaNs, empty cells) can be useful. You can also check if function will throw an error or a warning when it shoud:\r\n\r\n\r\ntestthat::expect_error(1 / \"a\")\r\n\r\ntestthat::expect_warning(log(-1))\r\n\r\n\r\nOther tests can involve testing whether output is of specific size or class. Functions that will check for these aspects are:\r\n\r\n\r\ntestthat::expect_length()\r\ntestthat::expect_s3_class()\r\ntestthat::expect_s4_class()\r\ntestthat::expect_type()\r\n\r\n\r\nHow many tests for a function? (optional)\r\nEach function needs to have a single file for unit tests, but there can be multiple unit tests inside. For instance, if your function includes conditional statements, you should tests all of the conditions (e.g. TRUE/FALSE).\r\n\r\n\r\nset_y_if_x <- function(y, x = TRUE){\r\n  if (x == TRUE) {\r\n    y <- y + 1\r\n  }\r\n  y\r\n}\r\n\r\n\r\ntestthat::test_that(\"Checking expected outcome when x is TRUE\", {\r\n  test_y <- 1\r\n  expected_output <- 2\r\n  function_output <- set_y_if_x(test_y, x = TRUE)\r\n  testthat::expect_identical(function_output, expected_output)\r\n})\r\n\r\nTest passed \r\n\r\ntestthat::test_that(\"Checking expected outcome when x is FALSE\", {\r\n  test_y <- 1\r\n  expected_output <- 1\r\n  function_output <- set_y_if_x(test_y, x = FALSE)\r\n  testthat::expect_identical(function_output, expected_output)\r\n})\r\n\r\nTest passed \r\n\r\nYou can also have multiple “expect” functions inside one “test_that” statement. This could be useful when checking multiple properties of the output. For instance:\r\n\r\n\r\nchange_col_to_factor <- function(df, col_name) {\r\n  df[, col_name] <- as.factor(df[, col_name])\r\n  df\r\n}\r\n\r\ntestthat::test_that(\"Checking data frame column types are as expected\", {\r\n  test_df <- data.frame(\r\n    a = 1:3, \r\n    b = c(\"a\", \"b\", \"c\"), \r\n    c = c(\"A\", \"A\", \"B\")\r\n  )\r\n  function_output <- change_col_to_factor(test_df, col_name = \"c\")\r\n  \r\n  testthat::expect_type(function_output[, \"a\"], \"integer\")\r\n  testthat::expect_type(function_output[, \"b\"], \"character\")\r\n  testthat::expect_s3_class(function_output[, \"c\"], \"factor\")\r\n})\r\n\r\nTest passed \r\n\r\nTesting your package\r\nIt is good to run unit tests on the package whenever you change functionality. There is a simple way to do it:\r\n\r\n\r\ndevtools::test(\"pckgname\")\r\n\r\n\r\nUnExported functions (optional)\r\nTesting non exported functions:\r\n\r\n\r\ntestthat::expect_equal(pkgname:::function_name(input), expected_output)\r\n\r\n\r\nOnly exported functions will be loaded and directly accessible to users when they load a package.\r\nHowever it is possible to access non exported functions of a package:\r\n\r\n\r\npckgname:::nonExpfun(arg1)\r\n\r\n\r\nQuality Assurance\r\nComplex pipelines should contain unit tests that cover most functions. However, you still should have your code peer reviewed and quality assured by another analyst.\r\nTesting excercises\r\n\r\nExercises\r\n\r\n\r\n# 8. Create unit tests for both functions in your package.\r\n\r\n\r\n# 9. Run unit tests for the package.\r\n\r\n\r\nExample solutions\r\n\r\n\r\n# 8. Create unit tests for both functions in your package.\r\nusethis::use_testthat() # create folder for tests in your package\r\nusethis::use_test(\"add_3\") # this can be also created manually\r\n\r\n# copy the below into my.awesome.package/tests/testthat/test-add_3.R\r\ntestthat::testthat(\"Function adds 3 to a vector\", {\r\n  output <- add_3(1)\r\n  expected_output <- 4\r\n  testthat::expect_equal(output, expected_output)\r\n})\r\n\r\n\r\n# 9. Run unit tests for the package.\r\ndevtools::test(\"my.awesome.package\")\r\n\r\n\r\n\r\nHow to share your package?\r\nUpload the package folder on git, then people can simmply clone it and run devtools::install().\r\nYou can also add it on cran, but we won’t cover that here - see more advanced resources below.\r\nAdditional resources\r\nFor more information see:\r\nPackaging your code in R - book\r\nPackages in R and Python - course on LearningHub\r\nIntroduction to Unit Testing - course on LearningHub\r\nNote that LearningHub resources are only available for colleagues from ONS and other government departments.\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-25T18:27:38+01:00"
    },
    {
      "path": "panel_template.html",
      "title": "Panels template",
      "author": [],
      "contents": "\r\n\r\nContents\r\nTesting excercises\r\nQuiz 1\r\n\r\nTesting excercises\r\n\r\nExercises\r\n\r\n\r\n\r\nExample solutions\r\n\r\n\r\n\r\n\r\nQuiz 1\r\n\r\nQuestion\r\nWhat do you class as a small project?\r\n\r\nProject with less than 10 bespoke functions\r\n\r\n\r\nProject that comfortable fits in a single script\r\n\r\n\r\nProject producing less than 10 tables\r\n\r\n\r\nProject that uses no more than 3 scripts for analysis\r\n\r\nSee Answer\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-25T18:27:40+01:00"
    },
    {
      "path": "projects.html",
      "title": "Structure for analytical projects",
      "author": [],
      "contents": "\r\n\r\nContents\r\nCode structure\r\nSmall project\r\nStructure\r\nQuality assurance of code\r\nQuiz 1\r\n\r\nMedium project\r\nStructure\r\nQuality assurance\r\n\r\nLarge project\r\nStructure\r\nQuality assurance\r\nQuiz 2\r\nQuiz 3\r\n\r\n\r\nCode structure\r\nThere is no one good solution to structuring your RAP projects. There is a lot of flexibility in how you do it and it will depend on the type of work you do. Nevertheless, especially when you start with RAP it can be really helpful to have a template to use. What is the best practice for structuring a project is one of the most common questions when we start working on RAP with a new team. The examples below are one good way to do this, but not the only way. Some of advice here is universal though - you should always have a README file and it should be clear which script you need to run.\r\nOptimal code structure will depend on volume and complexity of analysis. We’ll cover small, medium and big projects.\r\nSmall project\r\nStructure\r\nFor a small project it might be sufficient to have a single script that does all the work. In this case, the code should be structured as follows:\r\n\r\n\r\n# Config ----\r\n# specify all the variables that require user input at the top. All variables that might change from\r\n# run to run should be here: e.g. locations where to load data from, where to save the outputs, analytical parameters etc.\r\n\r\n# Load packages ----\r\n# library in all the required packages\r\n\r\n# Body of the script ----\r\n# Whatever the code actually does - you can have multiple sections here to make it easy to read.\r\n\r\n\r\nEven for small projects, contained within one script we should have a README file that contains the necessary documentation/instructions. README should ensure that another person can easily run the project.\r\nQuality assurance of code\r\nFor a small project any tests should be implemented in the body of the script - this can be simple sanity checks i.e. if statements printing a message or can use testthat “expect” functions. Some sanity checks might be useful, but for small projects most important part of QA will be for another analyst to quality assurance your code to check if it works as expected.\r\nQuiz 1\r\n\r\nQuestion\r\nWhat do you class as a small project?\r\n\r\nProject with less than 10 bespoke functions\r\n\r\n\r\nProject that comfortable fits in a single script\r\n\r\n\r\nProject producing less than 10 tables\r\n\r\n\r\nProject that uses no more than 3 scripts for analysis\r\n\r\nSee Answer\r\nWhat do you class as a small project?\r\n\r\nProject with less than 10 bespoke functions\r\n\r\n\r\nProject that comfortable fits in a single script\r\n\r\n\r\nProject producing less than 10 tables\r\n\r\n\r\nProject that uses no more than 3 scripts for analysis\r\n\r\nOur guidance for small projects is aproppriate for projects that would fit in a single script.\r\n\r\nMedium project\r\nStructure\r\nIn a medium size project you will likely need to have multiple scripts. First, you’ll need a README file that will explain to any future users how to run the code, which parameters need to be updated and where. If there is no other documentation this is also the place to specify any dependencies, versions, authors etc. README should generally be in .txt format.\r\nYou should have a separate config file with all the variables that require user input. Config file can be e.g. in yaml or R script format. This way you are less likely to introduce errors into the analytical part of the project and it is easy to modify parameters.\r\nFor medium size projects, you should make your code modular and avoid repetition. This means employing functions to do the heavy lifting for you. Therefore, you’ll need another R script where all the functions are stored.\r\nFinally, you’ll have a “main” script (it doesn’t have to be called main, but it should be clear which one to run), that does all the work. To take advantage of the config and functions you created you can simply use the source() function to call these into your environment.\r\nproject/\r\n  README.txt\r\n  config.yaml OR config.R\r\n  functions.R\r\n  main.R\r\nQuality assurance\r\nFor a medium project you should consider creating unit tests for your functions. This can be done in a simple fashion e.g. by creating another R script that will source all the functions and run tests for them. You should still have another analyst QA your code.\r\nLarge project\r\nStructure\r\nUsually, best way to structure large or complex projects is going to be putting it in a package (see the packages page). Alternatively you could adopt a structure similar to a package, that will help you manage the abundance of code and tests you’ll need to produce.\r\nproject/\r\n\r\n  functions/\r\n    analytical_functions.R\r\n    data_processing_functions.R\r\n    super_complex_modelling_functions.R\r\n    \r\n  tests/\r\n    test_function_F.R\r\n    ...\r\n  \r\n  README.txt\r\n  config.yaml OR config.R\r\n  main.R\r\nQuality assurance\r\nFor a big project, you should really unit test your functions. As always code should be quality assured by another analyst. Ideally you should produce logs each time your code is run with outcomes of your sanity checks and any parameters specified in the config.\r\nQuiz 2\r\n\r\nQuestion\r\nWhat files every project should include?\r\n\r\nREADME, functions.R\r\n\r\n\r\nmain.R, config, functions.R\r\n\r\n\r\nREADME, main.R\r\n\r\n\r\nmain.R, config, README\r\n\r\nSee Answer\r\nWhat files every project should include?\r\n\r\nREADME, functions.R\r\n\r\n\r\nmain.R, config, functions.R\r\n\r\n\r\nREADME, main.R\r\n\r\n\r\nmain.R, config, README\r\n\r\nFor small projects config might be a section in the main script.\r\n\r\nQuiz 3\r\n\r\nQuestion\r\nWhat quality assurance of code should always be employed across small, medium and large projects?\r\n\r\npeer review of the code\r\n\r\n\r\ndual runs with another analyst and comparing results\r\n\r\n\r\nunit testing\r\n\r\nThis question refers to QA of code, not methodology or results. We only talk about QA of code in this tutorial.\r\nSee Answer\r\nWhat quality assurance of code should always be employed across small, medium and large projects?\r\n\r\npeer review of the code\r\n\r\n\r\ndual runs with another analyst and comparing results\r\n\r\n\r\nunit testing\r\n\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2023-05-25T18:27:42+01:00"
    }
  ],
  "collections": []
}
